<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>js on 么了&#39;s 博客</title>
    <link>/categories/js/</link>
    <description>Recent content in js on 么了&#39;s 博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <lastBuildDate>Wed, 28 Oct 2020 14:22:40 +0800</lastBuildDate>
    
	<atom:link href="/categories/js/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>如何快速、高效的将“false”转换为false</title>
      <link>/blog/note-6/</link>
      <pubDate>Wed, 28 Oct 2020 14:22:40 +0800</pubDate>
      
      <guid>/blog/note-6/</guid>
      <description>var myBoolean=new Boolean(); //下面的所有的代码行均会创建初始值为 false 的 Boolean 对象。 var myBoolean=new Boolean(0); var myBoolean=new Boolean(null); var myBoolean=new Boolean(&amp;#34;&amp;#34;); var myBoolean=new Boolean(false);//不带单引号的是false var myBoolean=new Boolean(NaN); //下面的所有的代码行均会创初始值为 true 的 Boolean 对象： var myBoolean=new Boolean(1); var myBoolean=new Boolean(true); var myBoolean=new Boolean(&amp;#34;true&amp;#34;); var myBoolean=new Boolean(&amp;#34;false&amp;#34;);//带单引号的字符串false最终等于true var myBoolean=new Boolean(&amp;#34;Bill Gates&amp;#34;); 解决方法    let bool = result === &amp;#39;false&amp;#39; ? false : true   let bool = { &amp;#39;true&amp;#39;: true, &amp;#39;false&amp;#39;: false }; bool[ v ] !</description>
    </item>
    
    <item>
      <title>promise</title>
      <link>/blog/promise-note/</link>
      <pubDate>Tue, 08 Sep 2020 18:22:40 +0800</pubDate>
      
      <guid>/blog/promise-note/</guid>
      <description>Promise.resolve() .then(() =&amp;gt; { console.log(&amp;#34;then1&amp;#34;); Promise.resolve().then(() =&amp;gt; { console.log(&amp;#34;then1-1&amp;#34;); }); }) .then(() =&amp;gt; { console.log(&amp;#34;then2&amp;#34;); }); // then1 → then1-1 → then2 结论：链式调用中，只有前一个 then 的回调执行完毕后，跟着的 then 中的回调才会被加入至微任务队列。
let p = Promise.resolve(); p.then(() =&amp;gt; { console.log(&amp;#34;then1&amp;#34;); Promise.resolve().then(() =&amp;gt; { console.log(&amp;#34;then1-1&amp;#34;); }); }).then(() =&amp;gt; { console.log(&amp;#34;then1-2&amp;#34;); }); p.then(() =&amp;gt; { console.log(&amp;#34;then2&amp;#34;); }); // then1 → then2 → then1-1 → then1-2 结论：每个链式调用的开端会首先依次进入微任务队列。
let p = Promise.resolve().then(() =&amp;gt; { console.log(&amp;#34;then1&amp;#34;); Promise.resolve().then(() =&amp;gt; { console.log(&amp;#34;then1-1&amp;#34;); }); }).</description>
    </item>
    
    <item>
      <title>数字算法的精度问题</title>
      <link>/blog/note-5/</link>
      <pubDate>Mon, 07 Sep 2020 18:22:40 +0800</pubDate>
      
      <guid>/blog/note-5/</guid>
      <description>var a= &amp;#39;7.7&amp;#39;; var d = a * 687; // d = 5289.900000000001 会产生精度差的问题
加法 function (arg1, arg2){ var r1, r2, m; try {r1 = arg1.toString().split(&amp;#39;.&amp;#39;)[1].length} catch(e) {r1 = 0} // arg1小数点后的数字长度 	try {r2 = arg1.toString().split(&amp;#39;.&amp;#39;)[1].length} catch(e) {r2 = 0} // arg2小数点后的数字长度 	m = Math.pow(10, Math.max(r1, r2)) // 取(r1,r2)中最大值，10的 次方 	return ( arg1*m + arg2*m ) / m } 此方法解决 加法函数的精度问题
⚠️可以直接toFixed
乘法 function (arg1, arg2){ var m; try {m += arg1.</description>
    </item>
    
    <item>
      <title>页面跳转并传参</title>
      <link>/blog/jumpwithparam/</link>
      <pubDate>Sat, 25 Jul 2020 18:22:40 +0800</pubDate>
      
      <guid>/blog/jumpwithparam/</guid>
      <description>页面跳转并传参 不能传列表
入参url 跳转链接
入参JSON Object 自动转换 key:value value只能为字符串
var jumpWithParam = function(url, obj){ let jsonStr = JSON.stringify(obj); jsonStr = jsonStr.substr(1,jsonStr.length-2).replace(/&amp;#34;/g,&amp;#39;&amp;#39;); let jsonList = jsonStr.split(&amp;#39;,&amp;#39;); for(let i=0;i&amp;lt;jsonList.length;i++){ if(i!==0){ url=url+&amp;#39;&amp;amp;&amp;#39;; } else{ url=url+&amp;#39;?&amp;#39;; } let KVpair = jsonList[i].split(&amp;#39;:&amp;#39;); url = url + KVpair[0]+&amp;#39;=&amp;#39;+KVpair[1]; } console.log(url); my.navigateTo({ url: url }); }; </description>
    </item>
    
    <item>
      <title>鼠标拖动实现</title>
      <link>/blog/drag/</link>
      <pubDate>Fri, 10 Apr 2020 14:22:40 +0800</pubDate>
      
      <guid>/blog/drag/</guid>
      <description>/html &amp;lt;div id=&amp;#34;xxx&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; /javascript let dragging = false; let position = null; xxx.addEventListener(&amp;#39;mousedown&amp;#39;,function(e){ dragging = true position = [e.clientX, e.clientY] }) document.addEventListener(&amp;#39;mousemove&amp;#39;, function(e){ if(dragging === false){return} console.log(&amp;#39;hi&amp;#39;) const x = e.clientX const y = e.clientY const deltaX = x - position[0] const deltaY = y - position[1] const left = parseInt(xxx.style.left || 0) const top = parseInt(xxx.style.top || 0) xxx.style.left = left + deltaX + &amp;#39;px&amp;#39; xxx.style.top = top + deltaY + &amp;#39;px&amp;#39; position = [x, y] }) document.</description>
    </item>
    
    <item>
      <title>javascript的十个设计缺陷</title>
      <link>/blog/js-defect/</link>
      <pubDate>Sun, 29 Mar 2020 01:40:40 +0800</pubDate>
      
      <guid>/blog/js-defect/</guid>
      <description>为什么会有设计缺陷 设计阶段过于仓促 由于javascript的设计只用了十天，而且是为了向公司交差其本人并不愿意这样设计 另外这语言的设计初衷，是为了解决一些简单的网页互动，并没有考虑复杂应用的需要。
没有先例 Javascript同时结合了函数式编程和面向对象编程的特点，直到今天，js 仍是世界上唯一使用 Prototype继承模型的主要语言，使它没有设计先例作为参考。
过早的标准化 Javascript的发展非常快，根本没有时间调整设计。
95年5月，设计方案定稿；10月解释器开发成功；12月，向市场推出，立刻被广泛接受，全世界的用户大量使用。js缺乏从小到大慢慢累计用户的过程，而是连续的爆炸式增长。js的规格还没来得及调整就固化了。
96年8月，微软强势介入推出自己的脚本语言Jscript；11月，网景公司为了压制微软决定申请js的国际标准；
97年6月，第一个国际标准ECMA-262正式颁布。
相比之下，C语言问世20年才颁布国际标准。
Javascript的十个设计缺陷  不适合开发大型程序 非常小的标准库 null 和 undefined 全局变量难以控制 自动插入行尾分号 加号运算符 NAN 数组和对象的区分 == 和 === 基本类型的包装对象  如何看待Javascript Javascript其实并不算太糟，它的编程能力很强大。 如果遵守良好的编程规范，加上第三方函数库的帮助，JS的缺陷大部分可以规避。 还有JS目前是网页编程的唯一语言，许多新项目大大的扩展了它的用途，例如node.js,coffeeScript</description>
    </item>
    
  </channel>
</rss>