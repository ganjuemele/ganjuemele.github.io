<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>js on 么了&#39;s 博客</title>
    <link>/categories/js/</link>
    <description>Recent content in js on 么了&#39;s 博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <lastBuildDate>Fri, 11 Dec 2020 00:07:40 +0800</lastBuildDate><atom:link href="/categories/js/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>深拷贝</title>
      <link>/blog/js-note2/</link>
      <pubDate>Fri, 11 Dec 2020 00:07:40 +0800</pubDate>
      
      <guid>/blog/js-note2/</guid>
      <description>浅拷贝的场景 展开运算符 const a = { en: &amp;#39;Bye&amp;#39;, de: &amp;#39;Tschüss&amp;#39; } let b = {...a} b.de = &amp;#39;Ciao&amp;#39; console.log(b.de) // Ciao console.log(a.de) // Tschüss const c = {...a,...b} Object.assign() 用于将所有可枚举属性的值从一个或多个源对象复制到目标对象，然后返回目标对象。
第一个参数是被修改和最终返回的值，第二个参数是你要拷贝的对象。通常，只需要给第一个参数传入一个空对象，这样可以避免修改已有的数据。
const a = { en: &amp;#39;Bye&amp;#39;, de: &amp;#39;Tschüss&amp;#39; } let b = Object.assign({}, a) b.de = &amp;#39;Ciao&amp;#39; console.log(b.de) // Ciao console.log(a.de) // Tschüss 拷贝数组 const a = [1,2,3] let b = [...a] b[1] = 4 console.log(b[1]) // 4 console.log(a[1]) // 2 数组方法——map, filter, reduce, Array.</description>
    </item>
    
    <item>
      <title>创建优雅结束的函数</title>
      <link>/blog/js-note1/</link>
      <pubDate>Tue, 17 Nov 2020 22:22:40 +0800</pubDate>
      
      <guid>/blog/js-note1/</guid>
      <description>用return结束一个函数很简单，但是，想要能够在将来的某个时刻返回函数，然后再继续执行。
使用ES6中的生成器函数（generator function） 这是可以进入和退出并记住其状态的函数。
function* taskRunner(){ console.log(&amp;#39;doing sth&amp;#39;) yield function(){ console.log(&amp;#39;第一步&amp;#39;)	} console.log(&amp;#39;doing sth after first&amp;#39;) yield function(){ console.log(&amp;#39;second&amp;#39;) } console.log(&amp;#39;after second&amp;#39;) } var task = taskRunner(); task.next().value() task.next().value() task.next() 输出：
// doing sth // 第一步  // doing sth after first // second  // after second // {value: undefined, done: true} 可以用来遍历一组任务，每次通过一条yield语句和一个函数表达式前进一步
function* idMaker(){ var index = 0; while(true){ yield index++; } } var gen = idMaker(); console.log(gen.next().value)	// 0 console.</description>
    </item>
    
    <item>
      <title>promise</title>
      <link>/blog/promise-note/</link>
      <pubDate>Tue, 08 Sep 2020 18:22:40 +0800</pubDate>
      
      <guid>/blog/promise-note/</guid>
      <description>Promise.resolve() .then(() =&amp;gt; { console.log(&amp;#34;then1&amp;#34;); Promise.resolve().then(() =&amp;gt; { console.log(&amp;#34;then1-1&amp;#34;); }); }) .then(() =&amp;gt; { console.log(&amp;#34;then2&amp;#34;); }); // then1 → then1-1 → then2 结论：链式调用中，只有前一个 then 的回调执行完毕后，跟着的 then 中的回调才会被加入至微任务队列。
let p = Promise.resolve(); p.then(() =&amp;gt; { console.log(&amp;#34;then1&amp;#34;); Promise.resolve().then(() =&amp;gt; { console.log(&amp;#34;then1-1&amp;#34;); }); }).then(() =&amp;gt; { console.log(&amp;#34;then1-2&amp;#34;); }); p.then(() =&amp;gt; { console.log(&amp;#34;then2&amp;#34;); }); // then1 → then2 → then1-1 → then1-2 结论：每个链式调用的开端会首先依次进入微任务队列。
let p = Promise.resolve().then(() =&amp;gt; { console.log(&amp;#34;then1&amp;#34;); Promise.resolve().then(() =&amp;gt; { console.log(&amp;#34;then1-1&amp;#34;); }); }).</description>
    </item>
    
    <item>
      <title>数字算法的精度问题</title>
      <link>/blog/note-5/</link>
      <pubDate>Mon, 07 Sep 2020 18:22:40 +0800</pubDate>
      
      <guid>/blog/note-5/</guid>
      <description>var a= &amp;#39;7.7&amp;#39;; var d = a * 687; // d = 5289.900000000001 会产生精度差的问题
加法 function (arg1, arg2){ var r1, r2, m; try {r1 = arg1.toString().split(&amp;#39;.&amp;#39;)[1].length} catch(e) {r1 = 0} // arg1小数点后的数字长度 	try {r2 = arg1.toString().split(&amp;#39;.&amp;#39;)[1].length} catch(e) {r2 = 0} // arg2小数点后的数字长度 	m = Math.pow(10, Math.max(r1, r2)) // 取(r1,r2)中最大值，10的 次方 	return ( arg1*m + arg2*m ) / m } 此方法解决 加法函数的精度问题
⚠️可以直接toFixed
乘法 function (arg1, arg2){ var m; try {m += arg1.</description>
    </item>
    
    <item>
      <title>页面跳转并传参</title>
      <link>/blog/jumpwithparam/</link>
      <pubDate>Sat, 25 Jul 2020 18:22:40 +0800</pubDate>
      
      <guid>/blog/jumpwithparam/</guid>
      <description>页面跳转并传参 不能传列表
入参url 跳转链接
入参JSON Object 自动转换 key:value value只能为字符串
var jumpWithParam = function(url, obj){ let jsonStr = JSON.stringify(obj); jsonStr = jsonStr.substr(1,jsonStr.length-2).replace(/&amp;#34;/g,&amp;#39;&amp;#39;); let jsonList = jsonStr.split(&amp;#39;,&amp;#39;); for(let i=0;i&amp;lt;jsonList.length;i++){ if(i!==0){ url=url+&amp;#39;&amp;amp;&amp;#39;; } else{ url=url+&amp;#39;?&amp;#39;; } let KVpair = jsonList[i].split(&amp;#39;:&amp;#39;); url = url + KVpair[0]+&amp;#39;=&amp;#39;+KVpair[1]; } console.log(url); my.navigateTo({ url: url }); }; </description>
    </item>
    
    <item>
      <title>鼠标拖动实现</title>
      <link>/blog/drag/</link>
      <pubDate>Fri, 10 Apr 2020 14:22:40 +0800</pubDate>
      
      <guid>/blog/drag/</guid>
      <description>/html &amp;lt;div id=&amp;#34;xxx&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; /javascript let dragging = false; let position = null; xxx.addEventListener(&amp;#39;mousedown&amp;#39;,function(e){ dragging = true position = [e.clientX, e.clientY] }) document.addEventListener(&amp;#39;mousemove&amp;#39;, function(e){ if(dragging === false){return} console.log(&amp;#39;hi&amp;#39;) const x = e.clientX const y = e.clientY const deltaX = x - position[0] const deltaY = y - position[1] const left = parseInt(xxx.style.left || 0) const top = parseInt(xxx.style.top || 0) xxx.style.left = left + deltaX + &amp;#39;px&amp;#39; xxx.style.top = top + deltaY + &amp;#39;px&amp;#39; position = [x, y] }) document.</description>
    </item>
    
    <item>
      <title>javascript的十个设计缺陷</title>
      <link>/blog/js-defect/</link>
      <pubDate>Sun, 29 Mar 2020 01:40:40 +0800</pubDate>
      
      <guid>/blog/js-defect/</guid>
      <description>为什么会有设计缺陷 设计阶段过于仓促 由于javascript的设计只用了十天，而且是为了向公司交差其本人并不愿意这样设计 另外这语言的设计初衷，是为了解决一些简单的网页互动，并没有考虑复杂应用的需要。
没有先例 Javascript同时结合了函数式编程和面向对象编程的特点，直到今天，js 仍是世界上唯一使用 Prototype继承模型的主要语言，使它没有设计先例作为参考。
过早的标准化 Javascript的发展非常快，根本没有时间调整设计。
95年5月，设计方案定稿；10月解释器开发成功；12月，向市场推出，立刻被广泛接受，全世界的用户大量使用。js缺乏从小到大慢慢累计用户的过程，而是连续的爆炸式增长。js的规格还没来得及调整就固化了。
96年8月，微软强势介入推出自己的脚本语言Jscript；11月，网景公司为了压制微软决定申请js的国际标准；
97年6月，第一个国际标准ECMA-262正式颁布。
相比之下，C语言问世20年才颁布国际标准。
Javascript的十个设计缺陷  不适合开发大型程序 非常小的标准库 null 和 undefined 全局变量难以控制 自动插入行尾分号 加号运算符 NAN 数组和对象的区分 == 和 === 基本类型的包装对象  如何看待Javascript Javascript其实并不算太糟，它的编程能力很强大。 如果遵守良好的编程规范，加上第三方函数库的帮助，JS的缺陷大部分可以规避。 还有JS目前是网页编程的唯一语言，许多新项目大大的扩展了它的用途，例如node.js,coffeeScript</description>
    </item>
    
  </channel>
</rss>
