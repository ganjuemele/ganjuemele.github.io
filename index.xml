<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>么了&#39;s 博客</title>
    <link>/</link>
    <description>Recent content on 么了&#39;s 博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <lastBuildDate>Mon, 16 Mar 2020 23:22:40 +0800</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>box-shadow样式</title>
      <link>/blog/box-shadow/</link>
      <pubDate>Mon, 16 Mar 2020 23:22:40 +0800</pubDate>
      
      <guid>/blog/box-shadow/</guid>
      <description>button { font-size: 24px; height: 64px; width: 25%; border: #fff solid 1px; box-shadow: inset -2px -2px 1px rgba(0,0,0,0.45); $bg: #f2f2f2; &amp;amp;:nth-child(1) { background: $bg; } &amp;amp;:nth-child(2), &amp;amp;:nth-child(5) { background: darken($bg, 4%); } &amp;amp;:nth-child(3), &amp;amp;:nth-child(6), &amp;amp;:nth-child(9) { background: darken($bg, 8%); } &amp;amp;:nth-child(4), &amp;amp;:nth-child(7), &amp;amp;:nth-child(10), &amp;amp;:nth-child(13) { background: darken($bg, 12%); } &amp;amp;:nth-child(8), &amp;amp;:nth-child(11) { background: darken($bg, 16%); } &amp;amp;:nth-child(12), &amp;amp;:nth-child(14) { background: darken($bg, 20%); } &amp;amp;:nth-child(15) { background: darken($bg, 25%); } } -2px 就是未按下状态的样式;</description>
    </item>
    
    <item>
      <title>transform &amp; transition</title>
      <link>/blog/transformtransition/</link>
      <pubDate>Tue, 10 Mar 2020 20:22:40 +0800</pubDate>
      
      <guid>/blog/transformtransition/</guid>
      <description>Transform transform 属性用于旋转、倾斜、缩放、平移
有XYZ轴方向
⚠️只能转换由盒模型定位的元素
 scale(-2，2) 横向和纵向的缩放 translate(50%, 30px) 对象进行3D空间的位移  translate(-50%, -50%) // 可以做绝对定位元素的居中  rotate（30deg） 旋转30度 skew（30deg, 45deg）横向和纵向的倾斜 transform: none不应用任何转换 可以组合使用  对浏览器的兼容性支持
 Transition 过渡 用来补充中间帧
transition: 属性名 时长，属性名 时长 过渡方式 延迟
 transition-property: 过渡效果的 css 属性名 transition-duration：过渡完成所需的时间 transition-timing-function：速度效果的曲线。（复杂） transition-delay：延迟  all 代表所有属性
⚠️并不是所有属性都能过渡</description>
    </item>
    
    <item>
      <title>Vue的sync修饰符</title>
      <link>/blog/sync%E4%BF%AE%E9%A5%B0%E7%AC%A6/</link>
      <pubDate>Tue, 10 Mar 2020 15:22:40 +0800</pubDate>
      
      <guid>/blog/sync%E4%BF%AE%E9%A5%B0%E7%AC%A6/</guid>
      <description>修饰符sync 让子组件改变父组件状态的代码更容易被区分，作为编译时的语法糖存在，被扩展为一个自动更新父组件属性的v-on监听器。
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;div&amp;gt;{{bar}}&amp;lt;/div&amp;gt; &amp;lt;my-comp :foo.sync=&amp;#34;bar&amp;#34;&amp;gt;&amp;lt;/my-comp&amp;gt; // 下面扩展出来的写法 &amp;lt;!--&amp;lt;my-comp :foo=&amp;#34;bar&amp;#34; @update:foo=&amp;#34;val =&amp;gt; bar = val&amp;#34;&amp;gt;&amp;lt;/my-comp&amp;gt; --&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; Vue.component(&amp;#39;my-comp&amp;#39;, { template: &amp;#39;&amp;lt;div @click=&amp;#34;increment&amp;#34;&amp;gt;点我+1&amp;lt;/div&amp;gt;&amp;#39;, data: function() { return {copyFoo: this.foo} }, props: [&amp;#39;foo&amp;#39;], methods: { increment: function() { this.$emit(&amp;#39;update:foo&amp;#39;, ++this.copyFoo); } } }); new Vue({ el: &amp;#39;#app&amp;#39;, data: {bar: 0} }); &amp;lt;/script&amp;gt; ⚠️注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用 例如 v-bind:title.sync=”doc.title + ‘!’” 是无效的。 取而代之的是，你只能提供你想要绑定的属性名，类似 v-model。</description>
    </item>
    
    <item>
      <title>watch和computed</title>
      <link>/blog/watch%E5%92%8Ccomputed/</link>
      <pubDate>Mon, 09 Mar 2020 20:22:40 +0800</pubDate>
      
      <guid>/blog/watch%E5%92%8Ccomputed/</guid>
      <description>watch watch 有数据监听回调的作用，用来观察和响应Vue实例上的数据变动。data数据变化执行回调，在方法中传入新的值和旧的值.
immediate: true/false
deep: true/false; //监听 obj 的时候是否往深处查。默认false
⚠️不要使用箭头函数来定义 watch 函数
watch允许执行异步操作，在得到最终结果前，设置中间状态，这些是 computed 无法做到的
 computed computed 是计算属性，不需要加括号。
会根据所依赖的数据动态显示计算结果。计算结果会被缓存，computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次回去computed的值才会重新调用对应的getter来计算
&amp;lt;div id=&amp;#34;demo&amp;#34;&amp;gt;{{ fullName }}&amp;lt;/div&amp;gt; var vm = new Vue({ el: &amp;#39;#demo&amp;#39;, data: { firstName: &amp;#39;Foo&amp;#39;, lastName: &amp;#39;Bar&amp;#39; }, computed: { fullName: function () { return this.firstName + &amp;#39; &amp;#39; + this.lastName } } }) 默认只有getter，在需要时可以提供setter
// ... computed: { fullName: { // getter  get: function () { return this.</description>
    </item>
    
    <item>
      <title>Webpack入门</title>
      <link>/blog/webpack%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sat, 07 Mar 2020 20:22:40 +0800</pubDate>
      
      <guid>/blog/webpack%E5%85%A5%E9%97%A8/</guid>
      <description>安装webpack npm init -y
yarn add webpack webpack-cli --dev
安装插件css-loader,mini-css-extract-plugin,html-webpack-plugin
完成安装，创建 src 目录
执行当前目录下的webpack npx webpack
报出警告⚠️： WARNING in configuration The &#39;mode&#39; option has not been set, webpack will fallback to &#39;production&#39; for this value. Set &#39;mode&#39; option to &#39;development&#39; or &#39;production&#39; to enable defaults for each environment.
初始化webpack.config.js 新建 webpack.config.js
const path = require(&amp;#39;path&amp;#39;); module.exports = { mode: &amp;#39;development&amp;#39;,// 生产production /开发development 	entry: &amp;#39;./src/index.js&amp;#39;, devtool: &amp;#34;inline-source-map&amp;#34;, devServer: { contentBase: &amp;#39;.</description>
    </item>
    
    <item>
      <title>浏览器渲染过程</title>
      <link>/blog/render/</link>
      <pubDate>Fri, 06 Mar 2020 20:22:40 +0800</pubDate>
      
      <guid>/blog/render/</guid>
      <description>浏览器渲染过程  根据HTML构建html树（DOM） 根据css构建css树（cssom） 将两棵树合并成一颗渲染树（render tree） layout布局（文档流、盒模型、计算大小和位置） paint绘制（把边框颜色、文字颜色、阴影等画出来） compose合成（根据层叠关系展示页面）  如何更新样式
一般采用 js 来更新样式
div.style.display=&amp;#39;none&amp;#39; div.classList.add(&amp;#39;red&amp;#39;) div.remove() //直接删除节点 样式更新方式
 </description>
    </item>
    
    <item>
      <title>MVC浅谈</title>
      <link>/blog/mvc/</link>
      <pubDate>Thu, 05 Mar 2020 20:22:40 +0800</pubDate>
      
      <guid>/blog/mvc/</guid>
      <description>MVC 三个对象分别的作用，伪代码示例 model： 数据管理，请求到的数据给 controller
view： 放视图相关的，html 渲染
controller： 监听并操作 view，调用 model 里面的数据
const Model = { data: {} 增,删,改,查(){} } const View = { html:`&amp;lt;div&amp;gt;&amp;lt;p&amp;gt;hello&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt; `, init(){} render(){} } const C = { init() { v.init() v.render() } methods(){} }  EventBus 有哪些 API，是做什么用的，给出伪代码示例 提供了 constructor; on; remove; trigger 等等方法
eventBus = $(window) m = { data: {&amp;#39;…&amp;#39;}, methods: { update(data){ 修改m.data eventBus.trigger(A) } } } 然后，用on方法监听这个事件A，一旦事件A触发（即数据变化了），就调用V的render重新渲染视图：
eventBus.on(A, ()=&amp;gt;{ v.</description>
    </item>
    
    <item>
      <title>宝可梦大探险</title>
      <link>/blog/%E6%96%B9%E5%8F%AF%E6%A2%A6/</link>
      <pubDate>Sun, 01 Mar 2020 20:22:40 +0800</pubDate>
      
      <guid>/blog/%E6%96%B9%E5%8F%AF%E6%A2%A6/</guid>
      <description>方可梦小秘诀  宝可梦的品质分为四种，普通，好，非常好，特殊 宝可梦在乐园里最多可以叠3层 点击图鉴可以更换查看闪光形态，遇到闪光宝可梦进化，激活图鉴信息 商店购入10个装饰物品就可以解锁纪念球，效果是每天190的礼券变为200个 签到送礼券 每天是22小时并不是24小时 探险奖励需要10次才能激活，激活后下一颗获得的P石必定为金色（拥有3种加成） 在队伍组建页面长按右边的宝可梦头像可以快速查看信息 每隔22小时你会在地图左上角免费领到一只宝可梦，当然也有可能是闪光的或者是进化的 点击名字可以给宝可梦改名  热门宝可梦料理 妙蛙种子/皮卡丘：四大黄+任意一个大方块
杰尼龟：四大蓝+任意一个大方块
小火龙/伊布：四大红+任意一个大方块
吹捧尼多兰：五小灰、红红红大灰大灰
健美腕力：蓝蓝蓝大蓝；红红蓝蓝大黄；红蓝大黄大黄大灰
落石大岩蛇：红红灰灰大灰；黄黄灰灰大蓝；灰灰灰灰大灰
水炮乘龙：四大蓝+任意一个大方块；蓝蓝大蓝大黄大黄
迷你龙：四大蓝+任意一个大方块
化石翼龙：五大灰；灰大蓝大蓝大蓝大彩；三大蓝两大黄；
卡比兽：二小黄二大黄任意小；任意五大；
百变怪：四大蓝一大红；三大红两大灰；
肯泰罗：五大灰；三大红两大灰；
迷唇姐：五大红；蓝黄大蓝大黄大黄
飞天螳螂：五大黄；蓝大黄大黄大黄大彩；三大蓝两大黄；
袋龙：五大黄
吸盘魔偶：五大灰；蓝黄大蓝大黄大黄
超梦：彩虹海螺大黄各1；大红2
好用的技能以及可以学会这些技能的宝可梦 除了大岩蛇，三地鼠也会落石 隆隆岩，大钳蟹也可以变硬 藤鞭：妙蛙种子（一家），口呆花，大食花都可以学会。 水炮：很多水系精灵都会，水箭龟，哥达鸭，宝石海星、毒刺水母，海刺龙，乘龙还有水伊布。 龙星群：只有快龙。 缩入壳中：呆壳兽、菊石兽，化石盔，大舌贝，水箭龟 极光幕：迷唇姐，急冻鸟还有乘龙这 健美：超梦，腕力家族还有飞腿郎可以学会。 吹捧：尼多兰、尼多朗、催眠貘</description>
    </item>
    
    <item>
      <title>Http和Https</title>
      <link>/blog/http/</link>
      <pubDate>Tue, 25 Feb 2020 13:13:40 +0800</pubDate>
      
      <guid>/blog/http/</guid>
      <description>HTTP协议（HyperText Transfer Protocol超文本传输协议）是因特网上应用最广泛的一种网络协议，所有www文件都必须遵守这个标准。 HTTP是一个基于TCP/IP通信协议来传递数据。  HTTP工作原理 HTTP协议工作于客户端—服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端（web服务器）发送所有请求。 web服务器根据接受的请求，向客户端发送响应信息。 HTTP默认端口：80，也可以改为8080或者其他端口。  ⚠️注意事项：
 HTTP是无连接：无连接就是限制每次连接只处理一个请求，并收到客户的应答后即断开。采用这种方式可以节省传输时间。 HTTP是媒体独立的：只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送 HTTP是无状态：无状态是指协议对于事物处理没有记忆能力。缺少状态意味着如果后续处理需要之前的信息，则必须重新传，导致每次连接传送的数据量增大  通信流程： Web Browser网络浏览器 &amp;lt;—— HTTP协议 ——&amp;gt; HTTP Server &amp;lt;———&amp;gt; CGI Program(Common Gateway Interface通用网关接口) &amp;lt;———&amp;gt; Database数据库
HTTP请求方法 1.0： GET，POST，HEAD 1.1：OPTIONS，PUT，PATCH，DELETE，TRACE和CONNECT
状态码 200 — 请求成功 301 — 资源被永久转移到其它URL 404 — 请求的资源不存在 500 — 内部服务器错误
 HTTPS HTTPS（Hyper Text Transfer Protocol over SecureSocket Layer）超文本传输安全协议， 是以安全为目标的通道，在http的基础上通过传输加密和身份验证保证了传输过程的安全性。HTTP+SSL层。 主要通过数字认证、加密算法、非对称密钥等技术完成数据加密实现互联网传输安全保护，主要设计目标：   数据保密性：保证数据内容在传输过程中不会被第三方查看 数据完整性：及时发现被第三方篡改的传输内容，如果调包，能轻松发现并拒收 身份校验安全性：保证数据到达期望的目的地   优缺点   确保数据发送到正确的客户机和服务器</description>
    </item>
    
    <item>
      <title>Git远程仓库</title>
      <link>/blog/git%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</link>
      <pubDate>Mon, 24 Feb 2020 10:22:40 +0800</pubDate>
      
      <guid>/blog/git%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</guid>
      <description>git 远程仓库 用SSH地址，复制ssh地址
ssh-keygen -t rsa -b 4096 -C 你的邮箱 cat ~/.ssh/id_rsa.pub # 得到公钥内容 ssh -T git@github.com git remote add origin git@xxxxxxx git push -u origin master 新建了一个名为 ’19-12-26’ 的公钥 id_rsa 和 id_rsa.pub
git remote add origin git@XXXXXX 在本地添加远程仓库地址
origin是远程仓库的默认名字，可以换，建议不换
⚠️不要使用https地址，因为每次都需要密码
电脑上存放私钥，github留下公钥
上传代码是用私钥加密，github用公钥解密
git push -u origin master 推送本地 master 分支到远程 origin的master 分支
⚠️如果 提示 应该git pull…，那就git pull 一下
git pull是先把远程分支合并到本地对应的分支
如果远程分支没有更新过，才能省略 git pull
-u origin master 的意思是设置上游分支
之后就不用设置上游分支课，直接git pull；git push；</description>
    </item>
    
    <item>
      <title>Git本地仓库</title>
      <link>/blog/git-local/</link>
      <pubDate>Sun, 23 Feb 2020 18:22:40 +0800</pubDate>
      
      <guid>/blog/git-local/</guid>
      <description>使用github程序 &amp;raquo; install command line tool 来安装git
git config --global user.name 你的英文名 git config --global user.email 你的邮箱 git config --global push.default simple git config --global core.quotepath false git config --global core.autocrlf input 新建目录 &amp;raquo; 进入 &amp;raquo; git init
git add 路径 //选择哪些变动是需要提交的
.gitignore 是设置不需要提交的文件 //常见有::node_modules::; ::.DS_Store::; ::.idea::; ::.vscode::
git status 查看已经提交的文件
git status -sb 查看哪些文件有冲突
git commit -m “字符串”
git commit -v
git log 查看已提交更新的版本
git add . git commit -v git reset —hard a2bv7r //commit的版本号值</description>
    </item>
    
    <item>
      <title>Axios笔记</title>
      <link>/blog/axios-note/</link>
      <pubDate>Sat, 22 Feb 2020 18:22:40 +0800</pubDate>
      
      <guid>/blog/axios-note/</guid>
      <description>Axios笔记 this.$axios.get(’/toutiao/index’, { //::这里设置域名参数:: params:{ key:’4ac7dbb103ad3977c50735edb9651431’, type:’tiyu’ }, //请求头配置 headers: {&#39;token&#39;:token } }) .then(res =&amp;gt; { this.newsList= res.data console.log(this.newsList) }) .catch( err=&amp;gt; { console.log(’新闻异常’) })  Axios 是一个基于 promise 的 HTTP 库 其特性：
 可以在浏览器中发送 XMLHttpRequests 可以在 node.js 中发送 http 请求 支持 Promise API 拦截请求和响应 能取消请求 转换请求数据和相应数据 自动转换 Json 数据 客户端支持保护安全免受 XSRF 攻击  </description>
    </item>
    
    <item>
      <title>cmd的操作</title>
      <link>/blog/cmd/</link>
      <pubDate>Wed, 19 Feb 2020 18:22:40 +0800</pubDate>
      
      <guid>/blog/cmd/</guid>
      <description>npm i -g tldr 太长不想读
recursive 递归的
echo 回声 ::echo::
force 强制
change 改变 cd中的::c::
directory 文件夹/目录 cd中的::d::
make ::mk::
move ::mv::
remove ::rm::
copy ::cp::
list ::ls::
link ::ln::
find ::find::
touch ::touch::
::pwd:: 展示当前的绝对路径
clear 清屏
 查看文件内容 cat 路径 全部查看
head 路径 头10行
tail 路径 尾10行
less 路径 看其中一屏部分
 增 touch 文件名
echo 内容 &amp;gt; 1.js //新建文件并添加内容
echo 内容 &amp;gt;&amp;gt; 1.js //追加内容到文件
echo -e “内/n容” &amp;gt;&amp;gt; 1.</description>
    </item>
    
    <item>
      <title>Flex &amp; Grid</title>
      <link>/blog/flex-grid/</link>
      <pubDate>Wed, 12 Feb 2020 18:22:40 +0800</pubDate>
      
      <guid>/blog/flex-grid/</guid>
      <description>Flexbox display: flex; align-items纵向对齐元素，可选以下几个值：
 flex-start: 元素与容器的顶部对齐。 flex-end: 元素与容器的底部对齐。 center: 元素纵向居中。 baseline: 元素在容器的基线位置显示。 stretch: 元素被拉伸以填满整个容器。  justify-content横向对齐元素:
 space-between ：分散对齐 space-around ：平均等宽横向对齐 flex-start(default)：默认 左对齐 flex-end ：右对齐 center ：居中  flex-direction属性定义了元素在容器里摆放的方向:
 row: 元素摆放的方向和文字方向一致。 row-reverse: 元素摆放的方向和文字方向相反。 column: 元素从上放到下。 column-reverse: 元素从下放到上。  order属性 设置单个元素的order。元素的属性默认值为0，但是我们设置这个属性为正数或负数。改变的单个flex元素的顺序
align-self设置其中单个元素的交叉轴位置
 flex-start: 元素与容器的顶部对齐。 flex-end: 元素与容器的底部对齐。 center: 元素纵向居中。 baseline: 元素在容器的基线位置显示。 stretch: 元素被拉伸以填满整个容器。  flex-wrap
 nowrap: 所有的元素都在一行。 wrap: 元素自动换成多行。 wrap-reverse: 元素自动换成逆序的多行。  flex-flow 是 flex-direction + flex-wrap两个属性的合体 可以同时接受两个 属性值。</description>
    </item>
    
    <item>
      <title>Hugo的配置</title>
      <link>/blog/hugo%E7%9A%84%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 10 Feb 2020 18:22:40 +0800</pubDate>
      
      <guid>/blog/hugo%E7%9A%84%E9%85%8D%E7%BD%AE/</guid>
      <description>首先需要将 themes/future-imperfect/examplesite/config.toml 复制到根目录替换原文件；  baseurl = &amp;#34;/&amp;#34; # 网站根路径，可以写成你后期站点对应的域名 languageCode = &amp;#34;en-us&amp;#34; # 网站支持语言 title = &amp;#34;Hugo Future Imperfect&amp;#34; # 网站标题 theme = &amp;#34;hugo-future-imperfect&amp;#34; # 网站主题 preserveTaxonomyNames = true paginate = 3 # 文章超出几篇后产生分页 disqusShortname = &amp;#34;shortname&amp;#34; googleAnalytics = &amp;#34;&amp;#34; pluralizeListTitles = false # Set the followings to true as part of your site SEO enableRobotsTXT = true canonifyURLs = true # [params] 下面的值将会构成模板里的 .Site.Params 变量 [params] # Sets the meta tag description description = &amp;#34;HTML5 UP theme, Future Imperfect with some extra goodies, ported by Julio Pescador.</description>
    </item>
    
    <item>
      <title>toml文档格式的数据定义</title>
      <link>/blog/toml/</link>
      <pubDate>Sun, 02 Feb 2020 18:22:40 +0800</pubDate>
      
      <guid>/blog/toml/</guid>
      <description>TOML　的全称是　Tom’s Obvious, Minimal Language，因为它的作者是 GitHub　联合创始人　Tom Preston-Werner 。
 TOML是大小写敏感的 # 表示注释 可以按照自己的意愿使用空格或者Tab缩进  先写一个 Hugo 博客/md文档的配置规范 +++ title = &amp;#34;标题名称&amp;#34; description = &amp;#34;&amp;#34; //副标题 draft = false //草稿 author = &amp;#34;么了&amp;#34; date = &amp;#34;2019-04-02&amp;#34; categories = [&amp;#34;笔记&amp;#34;,博客&amp;#34;&amp;#34;] // 设置分类，支持数组格式 series = [&amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;] slug = &amp;#34;url的尾部&amp;#34; tags = [] keywords: [&amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;] featured = &amp;#34;pic01.jpg&amp;#34; //外部索引图片地址用文件夹 /年份/月份/pic.jpg featuredalt = &amp;#34;Pic 1&amp;#34; featuredpath = &amp;#34;date&amp;#34; // 也可使用绝对路径 linktitle = &amp;#34;&amp;#34; publishdate // 定时未来发布的时间 type = &amp;#34;post&amp;#34; metaDataFormat = &amp;#34;toml&amp;#34; languageCode = &amp;#34;en-us&amp;#34; date = &amp;#34;2014-09-29T21:54:53-05:00&amp;#34; weight // 排序的权重，默认按时间降序 +++ Hugo 的 markdown 文件前置数据定义结构，支持三种格式的语法类型 例如： yaml --- title: &amp;#34;My First Post&amp;#34; date: 2019-03-26T08:47:11+01:00 draft: true --- toml +++ title: &amp;#34;My First Post&amp;#34; date: 2019-03-26T08:47:11+01:00 draft: true +++ json { &amp;#34;title&amp;#34;: &amp;#34;{{ replace .</description>
    </item>
    
  </channel>
</rss>