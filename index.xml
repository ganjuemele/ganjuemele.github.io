<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>么了&#39;s 博客</title>
    <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/</link>
    <description>Recent content on 么了&#39;s 博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <lastBuildDate>Fri, 12 Nov 2021 16:43:40 +0800</lastBuildDate><atom:link href="https://ganjuemele.github.io/https-ganjuemele.github.io-/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>逻辑分配运算符</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/es2021-1/</link>
      <pubDate>Fri, 12 Nov 2021 16:43:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/es2021-1/</guid>
      <description>1. ||= 或等于运算符 let a = false; let b = true; a ||= b //a=true  let c = 0; let d= true; c ||= d //c=true  let e= 1; let f = false; e ||= f //e=1 a ||= b 相当于 a || (a=b)
2. &amp;amp;&amp;amp;= 且等于运算符 function() { let a; let b = 0; let c = 1; a &amp;amp;&amp;amp;= 2; b &amp;amp;&amp;amp;= 2; c &amp;amp;&amp;amp;= 2; return typeof a === &amp;#39;undefined&amp;#39; &amp;amp;&amp;amp; b === 0 &amp;amp;&amp;amp; c === 2; }//true  function(){ let a; let i = 1; a &amp;amp;&amp;amp;= ++i; return typeof a === &amp;#39;undefined&amp;#39; &amp;amp;&amp;amp; i === 1; } a &amp;amp;&amp;amp;= b 相当于 a &amp;amp;&amp;amp; (a=b)</description>
    </item>
    
    <item>
      <title>js添加css动画变量</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/js-note4/</link>
      <pubDate>Wed, 28 Jul 2021 12:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/js-note4/</guid>
      <description>css动画，需要动态传入变量 &amp;lt;img src=&amp;#34;#&amp;#34; id=&amp;#34;ball&amp;#34; alt=&amp;#34;&amp;#34;&amp;gt; ballMove() { document.styleSheets[0] .insertRule(&amp;#34;@keyframes ballmove{from{margin-left:0} to{margin-left:100px;}}&amp;#34;) } 使用js把动画添加到全局样式库中， 还可以传入变量
img#ball { width:100px;height:100px; animation: ballmove 2s 1 forwards ease-out; -webkit-animation: ballmove 2s 1 forwards ease-out; } </description>
    </item>
    
    <item>
      <title>vue-方法调用alert组件</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/vue-note2/</link>
      <pubDate>Wed, 28 Jul 2021 11:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/vue-note2/</guid>
      <description>var alertComponent = function(content,callback,button) { if(button == undefined) { button = [{key:&amp;#39;alert&amp;#39;,text:&amp;#39;确定&amp;#39;}] } let ErrorAlert if(button.length===1){ ErrorAlert = Vue.extend({ template: &amp;#34;&amp;lt;MyAlert1 v-if=&amp;#39;showFlag&amp;#39; title=&amp;#39;Title&amp;#39;&amp;#34; + &amp;#34; :content=&amp;#39;alertContent&amp;#39; :operation=&amp;#39;alertButton[0].text&amp;#39; &amp;#34; + &amp;#34;:clickMaskHidden=&amp;#39;false&amp;#39; @cancel=&amp;#39;alertClick&amp;#39; /&amp;gt;&amp;#34;, components: {MyAlert1}, data(){return{ alertContent:content, showFlag:true, alertButton: button }}, methods: { alertClick(){ let that = this; setTimeout(()=&amp;gt;{that.showFlag = false},100); callback&amp;amp;&amp;amp;callback() } } }) } else { ErrorAlert = Vue.extend({ template: &amp;#34;&amp;lt;MyAlert2 v-if=&amp;#39;showFlag&amp;#39; title=&amp;#39;Title&amp;#39; &amp;#34; + &amp;#34;:cancelOperation=&amp;#39;alertButton[0].text&amp;#39; @cancel=&amp;#39;cancel&amp;#39;&amp;#34; + &amp;#34;:confirmOperate=&amp;#39;alertButton[1].text&amp;#39; @confirm=&amp;#39;confirm&amp;#39; /&amp;gt;&amp;#34;, components:{MyAlert2}, data(){ return{ alertContent:content, alertButton:button, showFlag: true } }, methods:{ cancel(){ let that = this; setTimeout(function(){that.</description>
    </item>
    
    <item>
      <title>锚点的跳转和返回</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/js-note3/</link>
      <pubDate>Wed, 28 Jul 2021 11:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/js-note3/</guid>
      <description>&amp;lt;div id=&amp;#34;task&amp;#34;&amp;gt; ... &amp;lt;/div&amp;gt; 点击事件 window.location.href = &amp;#39;#task&amp;#39;; 跳转后会在链接上加上 task， 之后要返回上级页面时，需要点击2次返回，在移动端上对用户不太友好。
所以改用
document.getElementById(&amp;#39;task&amp;#39;).scrollIntoView() 可以解决路由返回需要2次的问题，不会在url上加上task 的锚点</description>
    </item>
    
    <item>
      <title>oop面向对象</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/oop/</link>
      <pubDate>Thu, 13 May 2021 10:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/oop/</guid>
      <description>OOP， Object Oriented Programming
面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。
面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。
面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们我们使用的就是面向对象了。
面向过程：
优点： 性能比面向对象好，因为类调用时需要实例化，开销比较大，比较消耗资源。 缺点： 不易维护、不易复用、不易扩展.
优点： 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护 . 缺点： 性能比面向过程差
面向对象的三大特性：
1、封装 隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。
2、继承 提高代码复用性；继承是多态的前提。
3、多态 父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。
优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护 . 缺点：性能比面向过程差</description>
    </item>
    
    <item>
      <title>使用Vant的picker</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/vant-1/</link>
      <pubDate>Tue, 20 Apr 2021 10:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/vant-1/</guid>
      <description>&amp;lt;template&amp;gt; &amp;lt;!-- //时间选择--&amp;gt; &amp;lt;div @click=&amp;#34;isShowPopup=!isShowPopup&amp;#34;&amp;gt; {{日期}} &amp;lt;/div&amp;gt; &amp;lt;van-popup v-model=&amp;#34;isShowPopup&amp;#34; position=&amp;#34;bottom&amp;#34;&amp;gt; &amp;lt;van-picker show-toolbar :columns=&amp;#34;columns&amp;#34; @change=&amp;#34;onChange&amp;#34; @confirm=&amp;#34;onConfirm&amp;#34; @cancel=&amp;#34;onCancel&amp;#34; /&amp;gt; &amp;lt;/van-popup&amp;gt; &amp;lt;!-- // 状态选择--&amp;gt; &amp;lt;div @click=&amp;#34;isShowStat=!isShowStat&amp;#34;&amp;gt; {{状态}} &amp;lt;/div&amp;gt; &amp;lt;van-popup v-model=&amp;#34;isShowStat&amp;#34; position=&amp;#34;bottom&amp;#34; v-if=&amp;#34;isShowStat&amp;#34;&amp;gt; &amp;lt;van-picker show-toolbar :columns=&amp;#34;typeListStat&amp;#34; @confirm=&amp;#34;onConfirmStat&amp;#34; @cancel=&amp;#34;onCancel&amp;#34; /&amp;gt; &amp;lt;/van-popup&amp;gt; &amp;lt;/template&amp;gt; import Vue from &amp;#39;vue&amp;#39;; import {Picker, Popup} from &amp;#34;vant&amp;#34;; Vue.use(Picker,Popup) export default { data() { return{ isShowPopup:false, isShowStat: false, typeStat: [&amp;#39;全部明细&amp;#39;, 0], typeListStat: [{values:[&amp;#39;全部明细&amp;#39;,&amp;#39;积分奖励&amp;#39;,&amp;#39;积分扣减&amp;#39;],defaultIndex: 0}], columns:[{}] } }, methods: { onCancel(){ this.isShowPopup=false; this.isShowStat= false }, … … }, watch: { 日期改变() { this.</description>
    </item>
    
    <item>
      <title>React中的SVG loader</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/react-1/</link>
      <pubDate>Fri, 09 Apr 2021 14:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/react-1/</guid>
      <description>yarn eject yarn add svgo-loader --dev yarn add svg-sprite-loader --dev /config/webpack.config.js 文件中添加
return { module: { rules: [ {oneOf: [ //svg-sprite-loader  { test: /\.svg$/, use: [ { loader: &amp;#39;svg-sprite-loader&amp;#39;, options: { } }, { loader: &amp;#39;svgo-loader&amp;#39;, options: {} } ] } ]} ]} } import y from &amp;#39;../icons/pear.svg&amp;#39; require(&amp;#39;../icons/watermelon.svg&amp;#39;) console.log(y) //import需要log一下引入的内容 // 或者直接require svg &amp;lt;svg className=&amp;#34;icon&amp;#34;&amp;gt; // 匹配 id为pear的svg &amp;lt;use xlinkHref=&amp;#34;#pear&amp;#34;/&amp;gt; &amp;lt;/svg&amp;gt; &amp;lt;svg className=&amp;#34;icon&amp;#34;&amp;gt; &amp;lt;use xlinkHref=&amp;#34;#watermelon&amp;#34;/&amp;gt; &amp;lt;/svg&amp;gt; ⚠️注意：react添加了tree shaking 的优化功能，会把脚本中未使用的声明删除掉.</description>
    </item>
    
    <item>
      <title>React Router</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/react-router/</link>
      <pubDate>Thu, 08 Apr 2021 14:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/react-router/</guid>
      <description>function App() { return( &amp;lt;Router&amp;gt; &amp;lt;Link to=&amp;#34;/home&amp;#34;&amp;gt;首页&amp;lt;/Link&amp;gt; &amp;lt;Link to=&amp;#34;/content&amp;#34;&amp;gt;内容&amp;lt;/Link&amp;gt; &amp;lt;Link to=&amp;#34;/about&amp;#34;&amp;gt;关于&amp;lt;/Link&amp;gt; &amp;lt;Switch&amp;gt; &amp;lt;Route path=&amp;#34;/home&amp;#34;&amp;gt; &amp;lt;Home /&amp;gt; &amp;lt;/Route&amp;gt; &amp;lt;Route path=&amp;#34;/content&amp;#34;&amp;gt; &amp;lt;Content /&amp;gt; &amp;lt;/Route&amp;gt; &amp;lt;Route path=&amp;#34;/about&amp;#34;&amp;gt; &amp;lt;About /&amp;gt; &amp;lt;/Route&amp;gt; // 重定向 &amp;lt;Redirect exact from=&amp;#34;/&amp;#34; to=&amp;#34;home&amp;#34; /&amp;gt; // 404页面 &amp;lt;Route path=&amp;#34;*&amp;#34;&amp;gt; &amp;lt;NoMatch/&amp;gt; &amp;lt;/Route&amp;gt; &amp;lt;/Switch&amp;gt; &amp;lt;/Router&amp;gt; ) } function Home() { return &amp;lt;h2&amp;gt;记账&amp;lt;/h2&amp;gt;; } function About() { return &amp;lt;h2&amp;gt;记账&amp;lt;/h2&amp;gt;; } function Content() { return &amp;lt;h2&amp;gt;记账&amp;lt;/h2&amp;gt;; } function NoMatch() { return &amp;lt;h2&amp;gt;页面不存在404&amp;lt;/h2&amp;gt;; } </description>
    </item>
    
    <item>
      <title>React中的css in js库</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/react-css/</link>
      <pubDate>Thu, 08 Apr 2021 14:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/react-css/</guid>
      <description>//首先引入 import styled from &amp;#39;styled-components&amp;#39;; // 添加样式 const Wrapper = styled.div` border: 1px solid red; min-height:100vh; display:flex; `; &amp;lt;Wrapper&amp;gt;1111&amp;lt;/Wrapper&amp;gt; yarn add styled-components 使用yarn安装
styled-components 是一个针对 React 的 css in js 类库。 和所有同类型的类库一样，通过 js 赋能解决了原生 css 所不具备的能力，比如变量、循环、函数等。解决了 css 全局命名空间，避免样式冲突的问题，维护起来更加方便。
 优点:  贯彻 React 的 everything in JS 理念，降低 js 对 css 文件的依赖 保留前端开发 CSS 书写习惯，无学习和迁移成本 使用方便，不需要配置 webpack，开箱即用 不用再担心样式命名的问题，移除样式与组件之间的对应关系 样式可以使用变量，更加灵活 组件的逻辑、生命周期、样式、结构完全和其它组件解耦，对组件维护很有帮助
 缺点  可读性差，不方便直接看出组件的 html 元素</description>
    </item>
    
    <item>
      <title>node.js文件系统</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/file/</link>
      <pubDate>Fri, 12 Mar 2021 16:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/file/</guid>
      <description>Node.js文件系统模块 方法1：
// 引入 fs 模块 let fs = require(&amp;#34;fs&amp;#34;) let fs = window.require(&amp;#39;fs&amp;#39;) // vue中需要在全局引入  // fs.readFile(path, cb) fs.readFile(&amp;#39;./src/data.json&amp;#39;, function (err, data) { // data为文件内容  if(err) { return console.error(err) } }) // fs.writeFile(&amp;#39;文件路径&amp;#39;，&amp;#39;写入的内容&amp;#39;，fn) fs.writeFile(&amp;#39;./src/data.json&amp;#39;, &amp;#39;TEXT&amp;#39;, function (err, data) { if (err) { return console.error(err) } }) 方法2：
//需要的使用的地方 引入js文件 import xx from &amp;#39;../data/file.js&amp;#39; // file.js fs.readFile(&amp;#39;./src/data.json&amp;#39;, function (err, data) { if(err) { return console.error(err) } let dt = data.</description>
    </item>
    
    <item>
      <title>ios 屏幕安全距离 样式</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/safearea/</link>
      <pubDate>Tue, 02 Feb 2021 14:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/safearea/</guid>
      <description>env()和constant()，是IOS11新增特性， Webkit的css函数，用于设定安全区域与边界的距离，有4个预定义变量： safe-area-inset-left：安全区域距离左边边界的距离 safe-area-inset-right：安全区域距离右边边界的距离 safe-area-inset-top：安全区域距离顶部边界的距离 safe-area-inset-bottom：安全距离底部边界的距离
padding-bottom: constant(safe-area-inset-bottom); /*兼容 IOS&amp;lt;11.2*/ padding-bottom: env(safe-area-inset-bottom); /*兼容 IOS&amp;gt;11.2*/ ⚠️ 注意： env() 和 constant() 需要同时存在，而且顺序不能换。</description>
    </item>
    
    <item>
      <title>ESLint的配置</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/eslint%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Fri, 08 Jan 2021 11:50:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/eslint%E9%85%8D%E7%BD%AE/</guid>
      <description>ESlint可以高效的检查代码格式，让参与项目的所有工程师都能保持统一的代码风格。 其检测精度甚至可以精确到是否多一个空格或者少一个空格。 代码格式的统一对提高团队的协同开发效率有很大的帮助，特别是对有代码洁癖的工程师。
在项目根目录下创建.eslintrc.js （注意文件名前面有个“.”）
module.exports = { root: true, env: { node: true }, &amp;#39;extends&amp;#39;: [ &amp;#39;plugin:vue/essential&amp;#39;, &amp;#39;@vue/standard&amp;#39; ], rules: { &amp;#39;no-debugger&amp;#39;: process.env.NODE_ENV === &amp;#39;production&amp;#39; ? &amp;#39;error&amp;#39; : &amp;#39;off&amp;#39;, // 不检测语句末尾的分号  &amp;#39;semi&amp;#39;: [&amp;#39;off&amp;#39;, &amp;#39;always&amp;#39;], // 强制缩进为2个空格  &amp;#39;indent&amp;#39;: [&amp;#39;error&amp;#39;, 2], // 关闭函数名称跟括号之间的空格检测  &amp;#39;space-before-function-paren&amp;#39;: 0, // 忽略大括号内的空格  &amp;#39;object-curly-spacing&amp;#39;: 0 }, parserOptions: { parser: &amp;#39;babel-eslint&amp;#39; } } 这里说明下关于indent缩进的配置，要配合项目根目录下的.editorconfig
[*.{js,jsx,ts,tsx,vue}] indent_style = space &amp;lt;--这里定义缩进类型是空格还是tab indent_size = 2 &amp;lt;--这里需要与.eslintrc.js的indent对应 trim_trailing_whitespace = true insert_final_newline = true ⚠️ .</description>
    </item>
    
    <item>
      <title>electron 笔记</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/electron-note2/</link>
      <pubDate>Tue, 15 Dec 2020 10:50:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/electron-note2/</guid>
      <description>electron的应用结构 由三个支柱组成
 Chromium 用于显示网页内容。 Node.js 用于本地文件系统和操作系统。 自定义 APIs 用于使用经常需要的 OS 本机函数。 就是构建一个带有网页界面的node.js应用程序，或者说是一个无缝集成的网页  Main and Renderer 进程  主进程在浏览窗口中创建网页实例，每个浏览窗口实例中renderer进程运行网页。当一个浏览窗口实例被destroyed，对应的renderer进程也会被终止。 主进程管理 所有的页面，及其对应的renderer进程。 renderer进程只负责管理对应的网页,一个renderer进程崩溃不会影响到别的renderer进程。 渲染进程 通过IPC 与主进程通信 在网页上执行GUI操作。 由于安全考虑和可能的资源泄漏，直接从渲染器过程中调用与本地GUI有关的API受到限制。  进程间的通信可以通过： ipcMain 和 ipcRenderer</description>
    </item>
    
    <item>
      <title>electron的起手笔记</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/electron-note1/</link>
      <pubDate>Mon, 14 Dec 2020 22:50:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/electron-note1/</guid>
      <description>初始化一个electron 使用npm install &amp;amp; npm start 报错
改用yarn add electron@latest --save-dev来安装
npm start / yarn run start成功运行
// 从 electron 软件包导入了 app 和 BrowserWindow模块 。 const {app, BrowserWindow} = require(&amp;#39;electron&amp;#39;) const path = require(&amp;#39;path&amp;#39;) // 定义一个函数，该函数创建一个 新的浏览窗口 启用了节点集成 function createWindow () { const mainWindow = new BrowserWindow({ width: 800, height: 600, webPreferences: { preload: path.join(__dirname, &amp;#39;preload.js&amp;#39;) } }) // 将 index.html 文件加载到此窗口中 // 并打开开发人员工具  mainWindow.loadFile(&amp;#39;index.html&amp;#39;) } app.whenReady().then(() =&amp;gt; { // 通过调用 createWindow方法，在 electron app 第一次被初始化时创建了一个新的窗口。  createWindow() // 添加了一个新的侦听器，当应用程序不再有任何打开窗口时试图退出。 因为操作系统 窗口管理行为 ，此监听器在 macOS 上是一个禁门。  app.</description>
    </item>
    
    <item>
      <title>fetch的使用</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/fetch/</link>
      <pubDate>Mon, 14 Dec 2020 17:00:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/fetch/</guid>
      <description>fetch方法提供了一个接口，用来跨域异步获取资源
⚠️注意 fetch 的特性  当接收到一个错误的HTTP状态码时，从fetch()返回的Promise不会被标记为reject，即使响应的状态码为404或者500。会被标记为resolve，但是resolve的返回属性ok的值为false。只有网络故障或者请求被阻止时才会标记为reject。 fetch可以接收跨域cookies，也可以使用fetch建立跨域会话。 fetch不会发送cookies，  // 第二个可选参数，可配置请求体的对象 fetch(url, { body: JSON.stringify(data), // must match &amp;#39;Content-Type&amp;#39; header  cache: &amp;#39;no-cache&amp;#39;, // *default, no-cache, reload, force-cache, only-if-cached  credentials: &amp;#39;same-origin&amp;#39;, // include, same-origin, *omit  headers: { &amp;#39;user-agent&amp;#39;: &amp;#39;Mozilla/4.0 MDN Example&amp;#39;, &amp;#39;content-type&amp;#39;: &amp;#39;application/json&amp;#39; }, method: &amp;#39;POST&amp;#39;, // *GET, POST, PUT, DELETE, etc.  mode: &amp;#39;cors&amp;#39;, // no-cors, cors, *same-origin  redirect: &amp;#39;follow&amp;#39;, // manual, *follow, error  referrer: &amp;#39;no-referrer&amp;#39;, // *client, no-referrer  }) POST JSON数据 var url = &amp;#39;https://example.</description>
    </item>
    
    <item>
      <title>深拷贝</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/js-note2/</link>
      <pubDate>Fri, 11 Dec 2020 00:07:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/js-note2/</guid>
      <description>浅拷贝的场景 展开运算符 const a = { en: &amp;#39;Bye&amp;#39;, de: &amp;#39;Tschüss&amp;#39; } let b = {...a} b.de = &amp;#39;Ciao&amp;#39; console.log(b.de) // Ciao console.log(a.de) // Tschüss const c = {...a,...b} Object.assign() 用于将所有可枚举属性的值从一个或多个源对象复制到目标对象，然后返回目标对象。
第一个参数是被修改和最终返回的值，第二个参数是你要拷贝的对象。通常，只需要给第一个参数传入一个空对象，这样可以避免修改已有的数据。
const a = { en: &amp;#39;Bye&amp;#39;, de: &amp;#39;Tschüss&amp;#39; } let b = Object.assign({}, a) b.de = &amp;#39;Ciao&amp;#39; console.log(b.de) // Ciao console.log(a.de) // Tschüss 拷贝数组 const a = [1,2,3] let b = [...a] b[1] = 4 console.log(b[1]) // 4 console.log(a[1]) // 2 数组方法——map, filter, reduce, Array.</description>
    </item>
    
    <item>
      <title>flex-grow自动填充宽度高度</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/flex-grow/</link>
      <pubDate>Thu, 10 Dec 2020 11:47:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/flex-grow/</guid>
      <description>display: flex; // 占满宽度 flex-direction: row; // 占满高度 flex-direction: column; // 给父元素定义高度 height/min-height/max-height 子元素元素 flex-grow: 1; 当只有一个子元素的时候flex-grow:1;自动填充剩余的高度/宽度。
多个子元素时，会按照flex-grow的总值按比例分配剩余的空间</description>
    </item>
    
    <item>
      <title>小程序开发笔记-触底加载更多</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/mini-note1/</link>
      <pubDate>Thu, 10 Dec 2020 09:47:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/mini-note1/</guid>
      <description>onReachBottom() { // ... // 监听最外层的page是否滑动到底部 // 触发事件 } &amp;lt;scroll-view scroll-y=&amp;quot;{{true}}&amp;quot; onScrollToLower=&amp;quot;scrollMytrip&amp;quot;&amp;gt; &amp;lt;view&amp;gt;......&amp;lt;/view&amp;gt; &amp;lt;/scroll-view&amp;gt; scrollMytrip(){ // ... // 给带滚动条的模块 // onScrollToLower=&amp;quot;scrollMytrip&amp;quot; // 定义一个监听事件，监听模块内部是否触底 // 触发事件 } </description>
    </item>
    
    <item>
      <title>创建优雅结束的函数</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/js-note1/</link>
      <pubDate>Tue, 17 Nov 2020 22:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/js-note1/</guid>
      <description>用return结束一个函数很简单，但是，想要能够在将来的某个时刻返回函数，然后再继续执行。
使用ES6中的生成器函数（generator function） 这是可以进入和退出并记住其状态的函数。
function* taskRunner(){ console.log(&amp;#39;doing sth&amp;#39;) yield function(){ console.log(&amp;#39;第一步&amp;#39;)	} console.log(&amp;#39;doing sth after first&amp;#39;) yield function(){ console.log(&amp;#39;second&amp;#39;) } console.log(&amp;#39;after second&amp;#39;) } var task = taskRunner(); task.next().value() task.next().value() task.next() 输出：
// doing sth // 第一步  // doing sth after first // second  // after second // {value: undefined, done: true} 可以用来遍历一组任务，每次通过一条yield语句和一个函数表达式前进一步
function* idMaker(){ var index = 0; while(true){ yield index++; } } var gen = idMaker(); console.log(gen.next().value)	// 0 console.</description>
    </item>
    
    <item>
      <title>Vue3.0 记录01</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/vue3-note1/</link>
      <pubDate>Sun, 27 Sep 2020 16:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/vue3-note1/</guid>
      <description>//SwitchDemo 父组件 &amp;lt;template&amp;gt; &amp;lt;div v-for=&amp;#34;(item, index) in evo&amp;#34; :item=&amp;#34;item&amp;#34; &amp;gt; &amp;lt;Switch v-model:value=&amp;#34;clickStatus&amp;#34; :evo=&amp;#34;evo[index]&amp;#34; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script lang=&amp;#34;ts&amp;#34;&amp;gt; import Switch from &amp;#39;../lib/Switch.vue&amp;#39;; import { ref } from &amp;#39;vue&amp;#39; export default { components: { Switch }, data(){ return { evo: [&amp;#34;Normal&amp;#34;, &amp;#34;Shadow&amp;#34;, &amp;#34;Disabled&amp;#34;, &amp;#34;Text&amp;#34;], } }, setup(){ const clickStatus = ref(!0); return { clickStatus } } } &amp;lt;/script&amp;gt; // Switch 子组件 &amp;lt;template&amp;gt; &amp;lt;div class=&amp;#34;switch-module&amp;#34;&amp;gt; &amp;lt;button @click=&amp;#34;toggle&amp;#34; :class=&amp;#34;[{checked:value, orange:value}, {&amp;#39;switchShadow switchShadow-orange&amp;#39;:evo===&amp;#39;Shadow&amp;#39;}, {&amp;#39;checkedDisBgc-orange&amp;#39;:value===true&amp;amp;&amp;amp;toggleDisable===true}, {uncheckedDisBgc:value===false&amp;amp;&amp;amp;toggleDisable===true}]&amp;#34; :disabled=&amp;#34;evo===&amp;#39;Disabled&amp;#39;&amp;amp;&amp;amp;toggleDisable&amp;#34; &amp;gt; &amp;lt;span class=&amp;#34;switchControl&amp;#34; /&amp;gt; &amp;lt;span v-if=&amp;#34;evo===&amp;#39;Text&amp;#39;&amp;#34; class=&amp;#34;switchText&amp;#34; :class=&amp;#34;value?</description>
    </item>
    
    <item>
      <title>字体font-family</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/font-family/</link>
      <pubDate>Wed, 23 Sep 2020 12:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/font-family/</guid>
      <description>// 为什么这样写 font-family // 答案见 https://github.com/zenozeng/fonts.css/
font-family: -apple-system, &amp;#34;Noto Sans&amp;#34;, &amp;#34;Helvetica Neue&amp;#34;, Helvetica, &amp;#34;Nimbus Sans L&amp;#34;, Arial, &amp;#34;Liberation Sans&amp;#34;, &amp;#34;PingFang SC&amp;#34;, &amp;#34;Hiragino Sans GB&amp;#34;, &amp;#34;Noto Sans CJK SC&amp;#34;, &amp;#34;Source Han Sans SC&amp;#34;, &amp;#34;Source Han Sans CN&amp;#34;, &amp;#34;Microsoft YaHei&amp;#34;, &amp;#34;Wenquanyi Micro Hei&amp;#34;, &amp;#34;WenQuanYi Zen Hei&amp;#34;, &amp;#34;ST Heiti&amp;#34;, SimHei, &amp;#34;WenQuanYi Zen Hei Sharp&amp;#34;, sans-serif; 能使各个平台的字体看起来统一
中文字体也有英文名称
永远不要忘记声明英文字体，并且英文字体应该在中文字体之前 记住这个事实：绝大部分中文字体里包含英文字母（但是基本上都很丑），而英文字体里不包含中文字符。</description>
    </item>
    
    <item>
      <title>mock数据</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/mock/</link>
      <pubDate>Tue, 22 Sep 2020 17:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/mock/</guid>
      <description>Random.pick( arr ) 从数组中随机选取一个元素，并返回。  Random.pick([&amp;#39;a&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;i&amp;#39;, &amp;#39;o&amp;#39;, &amp;#39;u&amp;#39;]) // =&amp;gt; &amp;#34;o&amp;#34; Random.cname() 随机生成一个常见的中文姓名。  Random.cname() // =&amp;gt; &amp;#34;袁军&amp;#34; Random.csentence() Random.csentence( len ), Random.csentence( min, max ) 随机生成一段中文文本。  Random.csentence() // =&amp;gt; &amp;#34;第任人九同段形位第律认得。&amp;#34; Random.csentence(2) // =&amp;gt; &amp;#34;维总。&amp;#34; Random.csentence(1, 3) // =&amp;gt; &amp;#34;厂存。&amp;#34;  Random.word() Random.word( len ) Random.word( min, max ) 随机生成一个单词。
  Random.title()
  Random.ctitle()
  日期
  // =&amp;gt; &amp;#34;2002-10-23&amp;#34; Random.date(&amp;#39;yyyy-MM-dd&amp;#39;) // =&amp;gt; &amp;#34;1983-01-29&amp;#34; Random.</description>
    </item>
    
    <item>
      <title>css动画</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/css-transition/</link>
      <pubDate>Thu, 17 Sep 2020 12:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/css-transition/</guid>
      <description>.coupon-type .selected { color: #00B893; width: 20vw; padding-bottom: 2.6vw; position: relative; } .coupon-tab .selected::before { position: absolute; width: 20vw; left: 0; content: &amp;#39;&amp;#39;; bottom: 0; animation: tabBorder 500ms ease alternate; //tabBorder是动画的事件名 border-bottom: .6vw solid #00B893; } @keyframes tabBorder { //过渡left和width属性 0% {transition: left,width;left: 50%;width:0;} 100% {transition: left,width;width:20vw;left: 0;} } </description>
    </item>
    
    <item>
      <title>vue小知识</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/vue-note1/</link>
      <pubDate>Thu, 17 Sep 2020 12:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/vue-note1/</guid>
      <description>v-cloak解决页面闪烁问题 页面中的数据时异步获取的，在网络不好的情况下，渲染页面的时候会出现页面闪烁的效果，影响用户体验， v-cloak 指令保持在元素上直到关联实例结束编译，利用它的特性，结合 CSS 的规则 [v-cloak] { display: none } 一起使用就可以隐藏掉未编译好的 Mustache 标签，直到实例准备完毕
// template 中 &amp;lt;div class=&amp;#34;#app&amp;#34; v-cloak&amp;gt; &amp;lt;p&amp;gt;{{value.name}}&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; // css 中 [v-cloak] { display: none; } ⚠️需要注意:虽然解决了闪烁的问题，但这段时间内如果什么都不处理的话，会直接白屏，这并不是我们想要的效果，我们应该加一个 loading 或者骨架屏的效果，提升用户体验</description>
    </item>
    
    <item>
      <title>promise</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/promise-note/</link>
      <pubDate>Tue, 08 Sep 2020 18:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/promise-note/</guid>
      <description>Promise.resolve() .then(() =&amp;gt; { console.log(&amp;#34;then1&amp;#34;); Promise.resolve().then(() =&amp;gt; { console.log(&amp;#34;then1-1&amp;#34;); }); }) .then(() =&amp;gt; { console.log(&amp;#34;then2&amp;#34;); }); // then1 → then1-1 → then2 结论：链式调用中，只有前一个 then 的回调执行完毕后，跟着的 then 中的回调才会被加入至微任务队列。
let p = Promise.resolve(); p.then(() =&amp;gt; { console.log(&amp;#34;then1&amp;#34;); Promise.resolve().then(() =&amp;gt; { console.log(&amp;#34;then1-1&amp;#34;); }); }).then(() =&amp;gt; { console.log(&amp;#34;then1-2&amp;#34;); }); p.then(() =&amp;gt; { console.log(&amp;#34;then2&amp;#34;); }); // then1 → then2 → then1-1 → then1-2 结论：每个链式调用的开端会首先依次进入微任务队列。
let p = Promise.resolve().then(() =&amp;gt; { console.log(&amp;#34;then1&amp;#34;); Promise.resolve().then(() =&amp;gt; { console.log(&amp;#34;then1-1&amp;#34;); }); }).</description>
    </item>
    
    <item>
      <title>数字算法的精度问题</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/note-5/</link>
      <pubDate>Mon, 07 Sep 2020 18:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/note-5/</guid>
      <description>var a= &amp;#39;7.7&amp;#39;; var d = a * 687; // d = 5289.900000000001 会产生精度差的问题
加法 function (arg1, arg2){ var r1, r2, m; try {r1 = arg1.toString().split(&amp;#39;.&amp;#39;)[1].length} catch(e) {r1 = 0} // arg1小数点后的数字长度 	try {r2 = arg1.toString().split(&amp;#39;.&amp;#39;)[1].length} catch(e) {r2 = 0} // arg2小数点后的数字长度 	m = Math.pow(10, Math.max(r1, r2)) // 取(r1,r2)中最大值，10的 次方 	return ( arg1*m + arg2*m ) / m } 此方法解决 加法函数的精度问题
⚠️可以直接toFixed
乘法 function (arg1, arg2){ var m; try {m += arg1.</description>
    </item>
    
    <item>
      <title>App加载状态的几种类型</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/note-4/</link>
      <pubDate>Fri, 04 Sep 2020 10:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/note-4/</guid>
      <description>全页面加载 优点：适用于各个场景
缺点：时间不确定性，加载过慢容易丢失用户
例：常见的菊花图，和各种有意思的动画gif图
占位色块 优点：适合固定布局的页面，体验比全页面流畅
缺点：不适用于 布局多变的页面
分部加载 优点：先加载页面框架和文字信息，在网速较慢时，能提前预览即将出现的内容
缺点：只加载了部分内容的页面会影响整体的美观度，也会影响用户对页面内容的理解
懒加载 优点：只加载用户看的到的内容，页面加载速度快，服务器压力小，节省流量，体验好
缺点：网络状态不佳时，会出现体验不流畅，加载延迟等状况
预加载 优点：预先加载即将出现的内容，用户可以顺畅的交互，享受极快的加载速度
缺点：服务器压力增加，流量耗费增加
进度条加载 优点：反馈明确，易懂
缺点：页面无内容，美观度差
混合加载 优点：根据场景不同来设计，体验升级
缺点：需要对各个场景制定相应的规范，保证交互一致性</description>
    </item>
    
    <item>
      <title>小程序调用高德地图</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/amap/</link>
      <pubDate>Wed, 02 Sep 2020 14:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/amap/</guid>
      <description>小程序调用高德地图接口 function AMapWX(a) { this.key = a.key; this.requestConfig = { key: a.key, s: &amp;#39;rsx&amp;#39;, platform: &amp;#39;WXJS&amp;#39;, appname: a.key, sdkversion: &amp;#39;1.2.0&amp;#39;, logversion: &amp;#39;2.0&amp;#39; }; } AMapWX.prototype.getWxLocation = function (a, b) { my.getLocation({ type: &amp;#39;gcj02&amp;#39;, success: function (a) { var c = a.longitude + &amp;#39;,&amp;#39; + a.latitude; my.setStorage({key: &amp;#39;userLocation&amp;#39;, data: c}), b(c); }, fail: function (c) { my.getStorage({ key: &amp;#39;userLocation&amp;#39;, success: function (a) { a.data &amp;amp;&amp;amp; b(a.data); } }), a.fail({errCode: &amp;#39;0&amp;#39;, errMsg: c.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/note-3/</link>
      <pubDate>Sat, 15 Aug 2020 18:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/note-3/</guid>
      <description>支付宝小程序开发工具 v1.12.15中
0 &amp;lt; t &amp;lt; 10 这种写法在支付宝小程序中连写不会识别
需要写成0&amp;lt; t &amp;amp;&amp;amp; t&amp;lt; 10</description>
    </item>
    
    <item>
      <title>运行脚本</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/run-script/</link>
      <pubDate>Thu, 13 Aug 2020 18:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/run-script/</guid>
      <description>// gp.bat  hugo cd public git add . git commit -m &amp;#39;hugo&amp;#39; git push origin master cd .. 打开终端进入文件夹，直接 ./gp.bat 回车. 一键 hugo转译 直接 push上传</description>
    </item>
    
    <item>
      <title>小程序中生成条形码和二维码</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/qrcodebarcode/</link>
      <pubDate>Sun, 26 Jul 2020 18:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/qrcodebarcode/</guid>
      <description>&amp;lt;canvas class=&amp;#34;barcode&amp;#34; id=&amp;#34;barcode&amp;#34;/&amp;gt; &amp;lt;canvas class=&amp;#34;qrcode&amp;#34; id=&amp;#34;qrcode&amp;#34;/&amp;gt; npm install wxbarcode
从wxbarcode中拿出demo/utils文件夹。 把文件内的wx换成my就能使用。
import mybarcode from &amp;#39;./utils/index.js&amp;#39;; mybarcode.barcode(&amp;#39;barcode&amp;#39;, that.data.orderNo, 658, 140); mybarcode.qrcode(&amp;#39;qrcode&amp;#39;, that.data.orderNo, 440, 440); (编码格式, 编译的内容, width, height)</description>
    </item>
    
    <item>
      <title>支付宝小程序中slot的使用</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/slot/</link>
      <pubDate>Sat, 25 Jul 2020 18:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/slot/</guid>
      <description>&amp;lt;!-- /components/index/index.axml --&amp;gt; &amp;lt;view&amp;gt; &amp;lt;slot&amp;gt; &amp;lt;view&amp;gt;default slot &amp;amp; default value&amp;lt;/view&amp;gt; &amp;lt;/slot&amp;gt; &amp;lt;view&amp;gt;other&amp;lt;/view&amp;gt; &amp;lt;/view&amp;gt; // /pages/index/index.json { &amp;#34;usingComponents&amp;#34;: { &amp;#34;my-component&amp;#34;: &amp;#34;/components/index/index&amp;#34; } } &amp;lt;!-- /pages/index/index.axml --&amp;gt; &amp;lt;my-component /&amp;gt; 输出 default slot &amp;amp; default value other  &amp;lt;!-- /components/index/index.axml --&amp;gt; &amp;lt;view&amp;gt; &amp;lt;slot&amp;gt; &amp;lt;view&amp;gt;default slot &amp;amp; default value&amp;lt;/view&amp;gt; &amp;lt;/slot&amp;gt; &amp;lt;slot name=&amp;#34;header&amp;#34;/&amp;gt; &amp;lt;view&amp;gt;body&amp;lt;/view&amp;gt; &amp;lt;slot name=&amp;#34;footer&amp;#34;/&amp;gt; &amp;lt;/view&amp;gt; &amp;lt;!-- /pages/index/index.axml --&amp;gt; &amp;lt;my-component&amp;gt; &amp;lt;view slot=&amp;#34;header&amp;#34;&amp;gt;header&amp;lt;/view&amp;gt; &amp;lt;view slot=&amp;#34;footer&amp;#34;&amp;gt;footer&amp;lt;/view&amp;gt; &amp;lt;/my-component&amp;gt; 输出 default slot &amp;amp; default value header body footer </description>
    </item>
    
    <item>
      <title>页面跳转并传参</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/jumpwithparam/</link>
      <pubDate>Sat, 25 Jul 2020 18:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/jumpwithparam/</guid>
      <description>页面跳转并传参 不能传列表
入参url 跳转链接
入参JSON Object 自动转换 key:value value只能为字符串
var jumpWithParam = function(url, obj){ let jsonStr = JSON.stringify(obj); jsonStr = jsonStr.substr(1,jsonStr.length-2).replace(/&amp;#34;/g,&amp;#39;&amp;#39;); let jsonList = jsonStr.split(&amp;#39;,&amp;#39;); for(let i=0;i&amp;lt;jsonList.length;i++){ if(i!==0){ url=url+&amp;#39;&amp;amp;&amp;#39;; } else{ url=url+&amp;#39;?&amp;#39;; } let KVpair = jsonList[i].split(&amp;#39;:&amp;#39;); url = url + KVpair[0]+&amp;#39;=&amp;#39;+KVpair[1]; } console.log(url); my.navigateTo({ url: url }); }; </description>
    </item>
    
    <item>
      <title>模版字符串的使用</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/template-string/</link>
      <pubDate>Mon, 20 Jul 2020 18:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/template-string/</guid>
      <description>模板字符串（template string）是增强版的字符串，用反引号（`）标识 它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。
&amp;lt;navigator class=&amp;#34;vbox&amp;#34; open-type=&amp;#34;navigate&amp;#34; a:for=&amp;#34;{{ruleList}}&amp;#34; a:key=&amp;#34;{{item.index}}&amp;#34; url=&amp;#34;{{item.actType===&amp;#39;C&amp;#39; ?`/pages/mine/cashCouponInfo/cashCouponInfo?info=${item.info}` :`/pages/couponOperate/couponOperate?info=${item.info}`}}&amp;#34;&amp;gt; &amp;lt;/navigator&amp;gt; 反引号中可以写一个字符串，并且插入使用 ${变量名} 。</description>
    </item>
    
    <item>
      <title>组件中props的使用</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/my-component-1/</link>
      <pubDate>Sat, 18 Jul 2020 18:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/my-component-1/</guid>
      <description>//index.axml &amp;lt;my-component ruleList= &amp;#34;{{ruleList}}&amp;#34;/&amp;gt; //这里给组件传一个ruleList ⚠对象和数组只能stringify后传值️
//component.js 	Component({ mixins: [], data: { ruleList: [] }, props: { ruleList: &amp;#39;&amp;#39;, //接收传入的ruleList 	}, didUpdate() { this.setData({ ruleList: JSON.parse(this.props.ruleList) }); } }); //component.axml &amp;lt;view&amp;gt; {{ruleList[0].属性}} &amp;lt;/view&amp;gt; //在页面中就能调用ruleLIst的参数，并渲染 </description>
    </item>
    
    <item>
      <title>复制到粘贴板</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/copy/</link>
      <pubDate>Mon, 29 Jun 2020 18:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/copy/</guid>
      <description>&amp;lt;text class=&amp;#34;info-copy&amp;#34; onTap=&amp;#34;clickCopy&amp;#34;&amp;gt;复制&amp;lt;/text&amp;gt; data: { orderNumber: 232322333, copyNumber: &amp;#39;&amp;#39; }, clickCopy() { //复制功能 	my.setClipboard({ text: this.data.orderNumber, }); // 粘贴功能 	// my.getClipboard({ 	// success: ({ text }) =&amp;gt; { 	// this.setData({ copyNumber: text }); 	// }, 	// });  } </description>
    </item>
    
    <item>
      <title>小程序保存图片到相册</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/wp-%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87/</link>
      <pubDate>Thu, 07 May 2020 00:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/wp-%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87/</guid>
      <description>保存图片的到相册
判断权限问题，使用了wx.getSetting 和 wx.authorize的scpoe 获取和设置权限；
使用wx.downloadFile 和 wx.saveImageToPhotosAlbum 下载图片至相册；
onPicDl(e) { let picUrl = e.target.dataset.picurl; let that = this; wx.showToast({ icon: &amp;#39;loading&amp;#39;, title: &amp;#39;正在保存图片&amp;#39;, duration: 1200 }) //判断用户是否授权&amp;#34;保存到相册&amp;#34;  wx.getSetting({ success(res) { //没有权限，发起授权  if (!res.authSetting[&amp;#39;scope.writePhotosAlbum&amp;#39;]) { wx.authorize({ scope: &amp;#39;scope.writePhotosAlbum&amp;#39;, success() { //用户允许授权，保存图片到相册  that.setData({ picUrl: picUrl, }) that.savePhoto(); }, fail() { //用户点击拒绝授权，跳转到设置页，引导用户授权  wx.openSetting({ success() { wx.authorize({ scope: &amp;#39;scope.writePhotosAlbum&amp;#39;, success() { that.setData({ picUrl: picUrl, }) that.savePhoto(); } }) } }) } }) } else { that.</description>
    </item>
    
    <item>
      <title>data-**的用法</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/wp-data-%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 05 May 2020 20:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/wp-data-%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>&amp;lt;image src=&amp;quot;{{item.picCloudURL}}&amp;quot; class=&amp;quot;pic&amp;quot; data-picUrl=&amp;quot;{{item.picCloudURL}}&amp;quot; bindtap=&amp;quot;onPicPreview&amp;quot;/&amp;gt; data-picUrl可以用来传递参数
当图片的点击事件触发，可以用e.currentTarget.dataset.picurl来获取传输的值</description>
    </item>
    
    <item>
      <title>小程序-加载云数据库</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/wp-%E5%8A%A0%E8%BD%BD%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Sun, 03 May 2020 20:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/wp-%E5%8A%A0%E8%BD%BD%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>const db = wx.cloud.database() db.collection(&amp;#34;数据库集合名&amp;#34;).get({ success: function (res) { console.log(res) } }) </description>
    </item>
    
    <item>
      <title>小程序-图片预览</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/wp-%E5%9B%BE%E7%89%87%E9%A2%84%E8%A7%88/</link>
      <pubDate>Sun, 03 May 2020 20:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/wp-%E5%9B%BE%E7%89%87%E9%A2%84%E8%A7%88/</guid>
      <description>wx.previewImage({ current: &amp;#39;cloud://wp-5moue.7770-wp-5moue-1302009781/wallpaper/pic1@2x.png&amp;#39;, // 当前显示图片的http链接  urls: [`cloud://wp-5moue.7770-wp-5moue-1302009781/wallpaper/pic1@2x.png`] // 需要预览的图片http链接列表  // current: &amp;#39;https://7770-wp-5moue-1302009781.tcb.qcloud.la/wallpaper/pic%402x.png&amp;#39;,  // urls: [`https://7770-wp-5moue-1302009781.tcb.qcloud.la/wallpaper/pic%402x.png`]  }) </description>
    </item>
    
    <item>
      <title>github部署vue项目</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/git-note/</link>
      <pubDate>Fri, 10 Apr 2020 14:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/git-note/</guid>
      <description>git run build git branch P-pages //创建gh-pages分支 git checkout P-pages //切换到gh-pages分支 git add -f dist //强制把dist文件夹提交到github $ git subtree push --prefix dist origin P-pages //把dist文件夹单独部署到P-pages分支 这样就把dist目录和项目文件分开了</description>
    </item>
    
    <item>
      <title>鼠标拖动实现</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/drag/</link>
      <pubDate>Fri, 10 Apr 2020 14:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/drag/</guid>
      <description>/html &amp;lt;div id=&amp;#34;xxx&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; /javascript let dragging = false; let position = null; xxx.addEventListener(&amp;#39;mousedown&amp;#39;,function(e){ dragging = true position = [e.clientX, e.clientY] }) document.addEventListener(&amp;#39;mousemove&amp;#39;, function(e){ if(dragging === false){return} console.log(&amp;#39;hi&amp;#39;) const x = e.clientX const y = e.clientY const deltaX = x - position[0] const deltaY = y - position[1] const left = parseInt(xxx.style.left || 0) const top = parseInt(xxx.style.top || 0) xxx.style.left = left + deltaX + &amp;#39;px&amp;#39; xxx.style.top = top + deltaY + &amp;#39;px&amp;#39; position = [x, y] }) document.</description>
    </item>
    
    <item>
      <title>Vue实例&amp;模版语法</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/vue-note/</link>
      <pubDate>Thu, 09 Apr 2020 14:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/vue-note/</guid>
      <description>Object.freeze() 方法可以冻结一个对象， 冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性， 以及不能修改该对象已有属性的可枚举性、可配置性、可写性。
const object2 = Object.freeze(object1);  其中 object2 和 object1 是同一个对象
 Vue 实例的生命周期钩子不要写成箭头函数，给出的理由是什么?  箭头函数是和父级上下文绑定在一起的，this 不会是如你所预期的 Vue 实例 经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误。</description>
    </item>
    
    <item>
      <title>javascript的十个设计缺陷</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/js-defect/</link>
      <pubDate>Sun, 29 Mar 2020 01:40:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/js-defect/</guid>
      <description>为什么会有设计缺陷 设计阶段过于仓促 由于javascript的设计只用了十天，而且是为了向公司交差其本人并不愿意这样设计 另外这语言的设计初衷，是为了解决一些简单的网页互动，并没有考虑复杂应用的需要。
没有先例 Javascript同时结合了函数式编程和面向对象编程的特点，直到今天，js 仍是世界上唯一使用 Prototype继承模型的主要语言，使它没有设计先例作为参考。
过早的标准化 Javascript的发展非常快，根本没有时间调整设计。
95年5月，设计方案定稿；10月解释器开发成功；12月，向市场推出，立刻被广泛接受，全世界的用户大量使用。js缺乏从小到大慢慢累计用户的过程，而是连续的爆炸式增长。js的规格还没来得及调整就固化了。
96年8月，微软强势介入推出自己的脚本语言Jscript；11月，网景公司为了压制微软决定申请js的国际标准；
97年6月，第一个国际标准ECMA-262正式颁布。
相比之下，C语言问世20年才颁布国际标准。
Javascript的十个设计缺陷  不适合开发大型程序 非常小的标准库 null 和 undefined 全局变量难以控制 自动插入行尾分号 加号运算符 NAN 数组和对象的区分 == 和 === 基本类型的包装对象  如何看待Javascript Javascript其实并不算太糟，它的编程能力很强大。 如果遵守良好的编程规范，加上第三方函数库的帮助，JS的缺陷大部分可以规避。 还有JS目前是网页编程的唯一语言，许多新项目大大的扩展了它的用途，例如node.js,coffeeScript</description>
    </item>
    
    <item>
      <title>vue</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/note-2/</link>
      <pubDate>Fri, 27 Mar 2020 20:40:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/note-2/</guid>
      <description>&amp;lt;stylescopedlang=&amp;#39;scss&amp;#39;&amp;gt; .x::v-deep li { // 或者使用 /deep/ border: 1px solid red; } &amp;lt;/style&amp;gt; 往深处继续找 deep语法</description>
    </item>
    
    <item>
      <title>Vuex的总结</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/vuex/</link>
      <pubDate>Fri, 27 Mar 2020 14:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/vuex/</guid>
      <description>Vue.use(Vuex)
// ~/main.ts  new Vue({ router, store, //引用进去  render: h =&amp;gt; h(App) }).$mount(&amp;#39;#app&amp;#39;); const store = new Vuex.store({ state: { count:0 ... ... }, mutations: { method1 (state){ state.count }, ... } }) 组件components中使用
读：对象 computed获取 @Component({ components: {xxx}, computed: { tags() { return this.$store.state.count } } }) 类 js/ts export default class EditLabel extends Vue { get currentTag (){ return this.$store.state.currentTag } } 写： this.$store.commit(&amp;#39;updateTag&amp;#39;,{id:this.currentTag.id, name}); </description>
    </item>
    
    <item>
      <title>CSS 的各种选择器</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/css%E9%80%89%E6%8B%A9%E5%99%A8/</link>
      <pubDate>Thu, 26 Mar 2020 20:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/css%E9%80%89%E6%8B%A9%E5%99%A8/</guid>
      <description>组合选择器 `E,F` 多元素选择器，使用`逗号`分隔，同时匹配元素E和元素F `E F` 后代选择器，用`空格`分隔，匹配E元素所有的后代元素F `E&amp;gt;F` 子元素选择器，用`&amp;gt;`分隔，匹配E元素的所有直接子元素 `E+F` 直接相邻选择器，匹配E元素之后的相邻的同级元素F `E～F` 普通相邻选择器（弟弟选择器），匹配E元素之后的同级元素F `element#id2.class1.class2#id1` id和class选择器连写时中间没有分隔符， `.`和`#`可以充当分隔符元素  属性选择器 `E[attr]` 匹配所有具有属性为attr的元素(div[id]能选择所有具有id属性的div) `E[attr=value]` 匹配所有属性为value的元素(div[type=text]匹配id=text的div) `E[attr~=value]` 匹配所有属性attr具有多个空格分隔，其中一个值等于value的元素 `E[attr^=value]` 匹配属性attr值以value开头的元素 `E[attr$=value]` 匹配属性attr值以value结尾的元素 `E[attr^=value]` 匹配属性attr值包含value的元素  伪类选择器 `E:first-child` 匹配元素E的第一个子元素 `E:last-child` 最后一个子元素 `E:nth-child(n)` 匹配其父元素的第n个子元素，1开始 `E:hover` 匹配鼠标悬停位置的E元素 `E:focus` 匹配获得焦点的E元素 `E:link` 匹配未被点击的链接 `E:active` 匹配鼠标已经按下、还没有释放的E元素 `E:visited` 匹配所有已被点击的链接 `E:first-of-type` 匹配父元素下使用同种标签的第一个子元素，等同于nth-of-type(1)  伪元素选择器 `E::before` 在E元素之前插入生成的内容 `E::after` 在E元素之后插入生成的内容 `E::first-line` 匹配E元素的第一行 `E::first-letter` 匹配E元素的第一个字母  </description>
    </item>
    
    <item>
      <title>localStorage属性</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/ls%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Tue, 24 Mar 2020 20:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/ls%E5%B1%9E%E6%80%A7/</guid>
      <description>window.localStorage.setItem(&#39;_key&#39;,&#39;_value&#39;);
window.localStorage.getItem(&#39;_key&#39;)
window.localStorage.removeItem(&#39;_key&#39;)</description>
    </item>
    
    <item>
      <title>prompt的确定和取消事件</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/prompt/</link>
      <pubDate>Sun, 22 Mar 2020 16:40:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/prompt/</guid>
      <description>prompt事件触发，未输入标签名点击取消，也会新增一个空白标签， 这是因为点击取消， name === null
const name = window.prompt(&amp;#39;请输入标签名&amp;#39;); if (name === null){ // console.log(name,&amp;#39;null&amp;#39;) }else if (name === &amp;#39;&amp;#39;) { window.alert(&amp;#39;标签名不能为空&amp;#39;) } else (this.dataSource) { this.$emit(&amp;#39;update:dataSource&amp;#39;, [...this.dataSource, name]) } ⚠️这里要把（name===null）的情况放在较前位置进行判断
优化下
if (name === &amp;#39;&amp;#39;) {window.alert(&amp;#39;标签名不能为空&amp;#39;)} else if (name !== null &amp;amp;&amp;amp; this.dataSource) { this.$emit(&amp;#39;update:dataSource&amp;#39;, [...this.dataSource, name]) } </description>
    </item>
    
    <item>
      <title>数据库版本更新</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/localstorage-v/</link>
      <pubDate>Fri, 20 Mar 2020 16:40:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/localstorage-v/</guid>
      <description>window.localStorage.setItem(&#39;version&#39;,&#39;1.0.0&#39;)
初始的 Version &amp;lsquo;1.0.0&amp;rsquo;, 更改为 &amp;lsquo;2.0.0&amp;rsquo;，在 localStrage 中的数据需要新加入个 Date
const version = window.localStorage.getItem(&amp;#39;version&amp;#39;) || &amp;#39;0&amp;#39;; const recordList: Record[] = JSON.parse(window.localStorage.getItem(&amp;#39;recordList&amp;#39;) || &amp;#39;[]&amp;#39;); if(version &amp;lt; &amp;#39;2.0.0&amp;#39;){ //数据库升级 	//遍历之前的数据给添加日期，使数据结构相同 	recordList.forEach(record =&amp;gt; { record.createdAt = new Date(0) }) //保存数据 	window.localStorage.setItem(&amp;#39;recordList&amp;#39;,JSON.stringify(recordList)) } //设置新版本号 window.localStorage.setItem(&amp;#39;version&amp;#39;,&amp;#39;2.0.0&amp;#39;) 版本更新前先获取之前的版本号
数据迁移到新版本</description>
    </item>
    
    <item>
      <title>css的calc属性</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/css-calc/</link>
      <pubDate>Wed, 18 Mar 2020 22:40:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/css-calc/</guid>
      <description>当不能确定一个页面元素的 width/height，需要计算之后才能取得值；
calc() 计算 calc() 函数用于动态计算长度值。
需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)；
calc()函数支持&#39;+&#39;，&#39;-&#39;，&#39;*&#39;，&#39;/&amp;lsquo;运算
.tags { padding: 12px 0; height: calc(100vh - 495px); overflow: auto; .current { display: flex; flex-flow: wrap; li { width: 16vw; height: 16vw; text-align: center; margin: 4px calc(10vw - 30px); } } } </description>
    </item>
    
    <item>
      <title>meta标签个各种作用</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/meta/</link>
      <pubDate>Wed, 18 Mar 2020 20:40:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/meta/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Typescript</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/typescript/</link>
      <pubDate>Tue, 17 Mar 2020 20:40:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/typescript/</guid>
      <description>TS是一个强类型语言，使得开发更加严谨
优点  类型提示更加智能 编译时，还没运行代码就知道写错了 类型检查：无法点出错误的属性  TS 的一些语法 export default class Types extends Vue { type = &amp;#39;-&amp;#39;; selectType(type:string) { //需要给type加上类型 	if (type !== &amp;#39;-&amp;#39; &amp;amp;&amp;amp; type !== &amp;#39;+&amp;#39;) { throw new Error(&amp;#39;未知Type&amp;#39;) } this.type = type; } } </description>
    </item>
    
    <item>
      <title>写Vue组件的三种方式</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/vue-component/</link>
      <pubDate>Tue, 17 Mar 2020 20:40:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/vue-component/</guid>
      <description>  使用 JS 对象 export default { data, props, methods, created, ……}
  使用 TS 类 &amp;lt;script lang=&amp;quot;ts&amp;quot;&amp;gt; import {Component,Prop} from &#39;vue-property-decorator&#39;
  @Compotent export default class XXX extends Vue { xxx: string = &amp;#39;hi&amp;#39;; @Prop(Number) xxx: number | undefined; } //(Number)运行时检查xxx的参数类型是否为number //编译时 `xxx: number | undefined` 中的xxx可以为number也可以是undefined  使用 JS 类 &amp;lt;script lang=&amp;quot;js&amp;quot;&amp;gt;  @Compotent export default class XXX extends Vue { xxx = &amp;#39;hi&amp;#39; } </description>
    </item>
    
    <item>
      <title>Markdown代码块支持的语言</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/markdown/</link>
      <pubDate>Tue, 17 Mar 2020 01:02:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/markdown/</guid>
      <description>//``` 	代码块 //``` Markdown 代码块支持不同的语言高亮；会根据语言的不同，代码的高亮现实也会不同。
支持哪些语言    &amp;mdash; 语言 关键字 语言 关键字      Shell bash,shell C c,cpp    JSON json Perl perl,pl    C# c#,c-sharp,csharp CSS css    Java java JavaScript js,jscript,javascript    PHP php text text,plain    Python py,python Ruby ruby,ror,rb,rails    XML xml,xhtml,xslt,html F# f#,f-sharp,fsarp    SASS/SCSS sass,scss Scala scala    SQL sql Visual Basic vb,vbnet    Swift swift Go go,golang    diff&amp;amp;patch diff patch Erlang erl,erlang    Groovy groovy JavaFX jfx,javafx    ColdFusion coldfusion,cf Delphi delphi,pas,pascal    Objective C objc,obj-c &amp;ndash; xpp,dynamics-xpp    R r,s,splus matlab matlab    AppleScript applescript ActionScript3.</description>
    </item>
    
    <item>
      <title>box-shadow样式</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/box-shadow/</link>
      <pubDate>Mon, 16 Mar 2020 23:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/box-shadow/</guid>
      <description>button { font-size: 24px; height: 64px; width: 25%; border: #fff solid 1px; box-shadow: inset -2px -2px 1px rgba(0,0,0,0.45); $bg: #f2f2f2; &amp;amp;:nth-child(1) { background: $bg; } &amp;amp;:nth-child(2), &amp;amp;:nth-child(5) { background: darken($bg, 4%); } &amp;amp;:nth-child(3), &amp;amp;:nth-child(6), &amp;amp;:nth-child(9) { background: darken($bg, 8%); } &amp;amp;:nth-child(4), &amp;amp;:nth-child(7), &amp;amp;:nth-child(10), &amp;amp;:nth-child(13) { background: darken($bg, 12%); } &amp;amp;:nth-child(8), &amp;amp;:nth-child(11) { background: darken($bg, 16%); } &amp;amp;:nth-child(12), &amp;amp;:nth-child(14) { background: darken($bg, 20%); } &amp;amp;:nth-child(15) { background: darken($bg, 25%); } } -2px 就是未按下状态的样式;</description>
    </item>
    
    <item>
      <title>transform &amp; transition</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/transformtransition/</link>
      <pubDate>Tue, 10 Mar 2020 20:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/transformtransition/</guid>
      <description>Transform transform 属性用于旋转、倾斜、缩放、平移
有XYZ轴方向
⚠️只能转换由盒模型定位的元素
 scale(-2，2) 横向和纵向的缩放 translate(50%, 30px) 对象进行3D空间的位移  translate(-50%, -50%) // 可以做绝对定位元素的居中  rotate（30deg） 旋转30度 skew（30deg, 45deg）横向和纵向的倾斜 transform: none不应用任何转换 可以组合使用  对浏览器的兼容性支持
 Transition 过渡 用来补充中间帧
transition: 属性名 时长，属性名 时长 过渡方式 延迟
 transition-property: 过渡效果的 css 属性名 transition-duration：过渡完成所需的时间 transition-timing-function：速度效果的曲线。（复杂） transition-delay：延迟  all 代表所有属性
⚠️并不是所有属性都能过渡</description>
    </item>
    
    <item>
      <title>Vue的sync修饰符</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/sync%E4%BF%AE%E9%A5%B0%E7%AC%A6/</link>
      <pubDate>Tue, 10 Mar 2020 15:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/sync%E4%BF%AE%E9%A5%B0%E7%AC%A6/</guid>
      <description>修饰符sync 让子组件改变父组件状态的代码更容易被区分，作为编译时的语法糖存在，被扩展为一个自动更新父组件属性的v-on监听器。
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;div&amp;gt;{{bar}}&amp;lt;/div&amp;gt; &amp;lt;my-comp :foo.sync=&amp;#34;bar&amp;#34;&amp;gt;&amp;lt;/my-comp&amp;gt; // 下面扩展出来的写法 &amp;lt;!-- &amp;lt;my-comp :foo=&amp;#34;bar&amp;#34; @update:foo=&amp;#34;val =&amp;gt; bar = val&amp;#34;&amp;gt;&amp;lt;/my-comp&amp;gt; --&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; Vue.component(&amp;#39;my-comp&amp;#39;, { template: &amp;#39;&amp;lt;div @click=&amp;#34;increment&amp;#34;&amp;gt;点我+1&amp;lt;/div&amp;gt;&amp;#39;, data: function() { return {copyFoo: this.foo} }, props: [&amp;#39;foo&amp;#39;], methods: { increment: function() { this.$emit(&amp;#39;update:foo&amp;#39;, ++this.copyFoo); } } }); new Vue({ el: &amp;#39;#app&amp;#39;, data: {bar: 0} }); &amp;lt;/script&amp;gt; ⚠️注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用 例如 v-bind:title.sync=”doc.title + ‘!’” 是无效的。 取而代之的是，你只能提供你想要绑定的属性名，类似 v-model。</description>
    </item>
    
    <item>
      <title>watch和computed</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/watch%E5%92%8Ccomputed/</link>
      <pubDate>Mon, 09 Mar 2020 20:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/watch%E5%92%8Ccomputed/</guid>
      <description>watch watch 有数据监听回调的作用，用来观察和响应Vue实例上的数据变动。data数据变化执行回调，在方法中传入新的值和旧的值.
immediate: true/false
deep: true/false; //监听 obj 的时候是否往深处查。默认false
⚠️不要使用箭头函数来定义 watch 函数
watch允许执行异步操作，在得到最终结果前，设置中间状态，这些是 computed 无法做到的
 computed computed 是计算属性，不需要加括号。
会根据所依赖的数据动态显示计算结果。计算结果会被缓存，computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次回去computed的值才会重新调用对应的getter来计算
&amp;lt;div id=&amp;#34;demo&amp;#34;&amp;gt;{{ fullName }}&amp;lt;/div&amp;gt; var vm = new Vue({ el: &amp;#39;#demo&amp;#39;, data: { firstName: &amp;#39;Foo&amp;#39;, lastName: &amp;#39;Bar&amp;#39; }, computed: { fullName: function () { return this.firstName + &amp;#39; &amp;#39; + this.lastName } } }) 默认只有getter，在需要时可以提供setter
// ... computed: { fullName: { // getter  get: function () { return this.</description>
    </item>
    
    <item>
      <title>Webpack入门</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/webpack%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sat, 07 Mar 2020 20:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/webpack%E5%85%A5%E9%97%A8/</guid>
      <description>安装webpack npm init -y
yarn add webpack webpack-cli --dev
安装插件css-loader,mini-css-extract-plugin,html-webpack-plugin
完成安装，创建 src 目录
执行当前目录下的webpack npx webpack
报出警告⚠️： WARNING in configuration The &#39;mode&#39; option has not been set, webpack will fallback to &#39;production&#39; for this value. Set &#39;mode&#39; option to &#39;development&#39; or &#39;production&#39; to enable defaults for each environment.
初始化webpack.config.js 新建 webpack.config.js
const path = require(&amp;#39;path&amp;#39;); module.exports = { mode: &amp;#39;development&amp;#39;,// 生产production /开发development 	entry: &amp;#39;./src/index.js&amp;#39;, devtool: &amp;#34;inline-source-map&amp;#34;, devServer: { contentBase: &amp;#39;.</description>
    </item>
    
    <item>
      <title>浏览器渲染过程</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/render/</link>
      <pubDate>Fri, 06 Mar 2020 20:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/render/</guid>
      <description>浏览器渲染过程  根据HTML构建html树（DOM） 根据css构建css树（cssom） 将两棵树合并成一颗渲染树（render tree） layout布局（文档流、盒模型、计算大小和位置） paint绘制（把边框颜色、文字颜色、阴影等画出来） compose合成（根据层叠关系展示页面）  如何更新样式
一般采用 js 来更新样式
div.style.display=&amp;#39;none&amp;#39; div.classList.add(&amp;#39;red&amp;#39;) div.remove() //直接删除节点 样式更新方式
 </description>
    </item>
    
    <item>
      <title>MVC浅谈</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/mvc/</link>
      <pubDate>Thu, 05 Mar 2020 20:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/mvc/</guid>
      <description>MVC 三个对象分别的作用，伪代码示例 model： 数据管理，请求到的数据给 controller
view： 放视图相关的，html 渲染
controller： 监听并操作 view，调用 model 里面的数据
const Model = { data: {} 增,删,改,查(){} } const View = { html:` &amp;lt;div&amp;gt;&amp;lt;p&amp;gt;hello&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt; `, init(){} render(){} } const C = { init() { v.init() v.render() } methods(){} }  EventBus 有哪些 API，是做什么用的，给出伪代码示例 提供了 constructor; on; remove; trigger 等等方法
eventBus = $(window) m = { data: {&amp;#39;…&amp;#39;}, methods: { update(data){ 修改m.data eventBus.trigger(A) } } } 然后，用on方法监听这个事件A，一旦事件A触发（即数据变化了），就调用V的render重新渲染视图：
eventBus.on(A, ()=&amp;gt;{ v.</description>
    </item>
    
    <item>
      <title>宝可梦大探险</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/poke/</link>
      <pubDate>Sun, 01 Mar 2020 20:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/poke/</guid>
      <description>方可梦小秘诀  宝可梦的品质分为四种，普通，好，非常好，特殊 宝可梦在乐园里最多可以叠3层 点击图鉴可以更换查看闪光形态，遇到闪光宝可梦进化，激活图鉴信息 商店购入10个装饰物品就可以解锁纪念球，效果是每天190的礼券变为200个 签到送礼券 每天是22小时并不是24小时 探险奖励需要10次才能激活，激活后下一颗获得的P石必定为金色（拥有3种加成） 在队伍组建页面长按右边的宝可梦头像可以快速查看信息 每隔22小时你会在地图左上角免费领到一只宝可梦，当然也有可能是闪光的或者是进化的 点击名字可以给宝可梦改名  热门宝可梦料理 妙蛙种子/皮卡丘：四大黄+任意一个大方块
杰尼龟：四大蓝+任意一个大方块
小火龙/伊布：四大红+任意一个大方块
吹捧尼多兰：五小灰、红红红大灰大灰
健美腕力：蓝蓝蓝大蓝；红红蓝蓝大黄；红蓝大黄大黄大灰
落石大岩蛇：红红灰灰大灰；黄黄灰灰大蓝；灰灰灰灰大灰
水炮乘龙：四大蓝+任意一个大方块；蓝蓝大蓝大黄大黄
迷你龙：四大蓝+任意一个大方块
化石翼龙：五大灰；灰大蓝大蓝大蓝大彩；三大蓝两大黄；
卡比兽：二小黄二大黄任意小；任意五大；
百变怪：四大蓝一大红；三大红两大灰；
肯泰罗：五大灰；三大红两大灰；
迷唇姐：五大红；蓝黄大蓝大黄大黄
飞天螳螂：五大黄；蓝大黄大黄大黄大彩；三大蓝两大黄；
袋龙：五大黄
吸盘魔偶：五大灰；蓝黄大蓝大黄大黄
超梦：彩虹海螺大黄各1大红2；
好用的技能以及可以学会这些技能的宝可梦 除了大岩蛇，三地鼠也会落石 隆隆岩，大钳蟹也可以变硬 藤鞭：妙蛙种子（一家），口呆花，大食花都可以学会。 水炮：很多水系精灵都会，水箭龟，哥达鸭，宝石海星、毒刺水母，海刺龙，乘龙还有水伊布。 龙星群：只有快龙。 缩入壳中：呆壳兽、菊石兽，化石盔，大舌贝，水箭龟 极光幕：迷唇姐，急冻鸟还有乘龙这 健美：超梦，腕力家族还有飞腿郎可以学会。 吹捧：尼多兰、尼多朗、催眠貘</description>
    </item>
    
    <item>
      <title>Http和Https</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/http/</link>
      <pubDate>Tue, 25 Feb 2020 13:13:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/http/</guid>
      <description>HTTP协议（HyperText Transfer Protocol超文本传输协议）是因特网上应用最广泛的一种网络协议，所有www文件都必须遵守这个标准。 HTTP是一个基于TCP/IP通信协议来传递数据。  HTTP工作原理 HTTP协议工作于客户端—服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端（web服务器）发送所有请求。 web服务器根据接受的请求，向客户端发送响应信息。 HTTP默认端口：80，也可以改为8080或者其他端口。  ⚠️注意事项：
 HTTP是无连接：无连接就是限制每次连接只处理一个请求，并收到客户的应答后即断开。采用这种方式可以节省传输时间。 HTTP是媒体独立的：只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送 HTTP是无状态：无状态是指协议对于事物处理没有记忆能力。缺少状态意味着如果后续处理需要之前的信息，则必须重新传，导致每次连接传送的数据量增大  通信流程： Web Browser网络浏览器 &amp;lt;—— HTTP协议 ——&amp;gt; HTTP Server &amp;lt;———&amp;gt; CGI Program(Common Gateway Interface通用网关接口) &amp;lt;———&amp;gt; Database数据库
HTTP请求方法 1.0： GET，POST，HEAD 1.1：OPTIONS，PUT，PATCH，DELETE，TRACE和CONNECT
状态码 200 — 请求成功 301 — 资源被永久转移到其它URL 404 — 请求的资源不存在 500 — 内部服务器错误
 HTTPS HTTPS（Hyper Text Transfer Protocol over SecureSocket Layer）超文本传输安全协议， 是以安全为目标的通道，在http的基础上通过传输加密和身份验证保证了传输过程的安全性。HTTP+SSL层。 主要通过数字认证、加密算法、非对称密钥等技术完成数据加密实现互联网传输安全保护，主要设计目标：   数据保密性：保证数据内容在传输过程中不会被第三方查看 数据完整性：及时发现被第三方篡改的传输内容，如果调包，能轻松发现并拒收 身份校验安全性：保证数据到达期望的目的地   优缺点   确保数据发送到正确的客户机和服务器</description>
    </item>
    
    <item>
      <title>Git远程仓库</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/git%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</link>
      <pubDate>Mon, 24 Feb 2020 10:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/git%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</guid>
      <description>git 远程仓库 用SSH地址，复制ssh地址
ssh-keygen -t rsa -b 4096 -C 你的邮箱 cat ~/.ssh/id_rsa.pub # 得到公钥内容 ssh -T git@github.com git remote add origin git@xxxxxxx git push -u origin master 新建了一个名为 ’19-12-26’ 的公钥 id_rsa 和 id_rsa.pub
git remote add origin git@XXXXXX 在本地添加远程仓库地址
origin是远程仓库的默认名字，可以换，建议不换
⚠️不要使用https地址，因为每次都需要密码
电脑上存放私钥，github留下公钥
上传代码是用私钥加密，github用公钥解密
git push -u origin master 推送本地 master 分支到远程 origin的master 分支
⚠️如果 提示 应该git pull…，那就git pull 一下
git pull是先把远程分支合并到本地对应的分支
如果远程分支没有更新过，才能省略 git pull
-u origin master 的意思是设置上游分支
之后就不用设置上游分支课，直接git pull；git push；</description>
    </item>
    
    <item>
      <title>Git本地仓库</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/git-local/</link>
      <pubDate>Sun, 23 Feb 2020 18:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/git-local/</guid>
      <description>使用github程序 &amp;raquo; install command line tool 来安装git
git config --global user.name 你的英文名 git config --global user.email 你的邮箱 git config --global push.default simple git config --global core.quotepath false git config --global core.autocrlf input 新建目录 &amp;raquo; 进入 &amp;raquo; git init
git add 路径 //选择哪些变动是需要提交的
.gitignore 是设置不需要提交的文件 //常见有::node_modules::; ::.DS_Store::; ::.idea::; ::.vscode::
git status 查看已经提交的文件
git status -sb 查看哪些文件有冲突
git commit -m “字符串”
git commit -v
git log 查看已提交更新的版本
git add . git commit -v git reset —hard a2bv7r //commit的版本号值</description>
    </item>
    
    <item>
      <title>Axios笔记</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/axios-note/</link>
      <pubDate>Sat, 22 Feb 2020 18:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/axios-note/</guid>
      <description>Axios笔记 this.$axios.get(’/toutiao/index’, { //::这里设置域名参数:: params:{ key:’4ac7dbb103ad3977c50735edb9651431’, type:’tiyu’ }, //请求头配置 headers: {&#39;token&#39;:token } }) .then(res =&amp;gt; { this.newsList= res.data console.log(this.newsList) }) .catch( err=&amp;gt; { console.log(’新闻异常’) })  Axios 是一个基于 promise 的 HTTP 库 其特性：
 可以在浏览器中发送 XMLHttpRequests 可以在 node.js 中发送 http 请求 支持 Promise API 拦截请求和响应 能取消请求 转换请求数据和相应数据 自动转换 Json 数据 客户端支持保护安全免受 XSRF 攻击  </description>
    </item>
    
    <item>
      <title>SEO的站内优化</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/seo/</link>
      <pubDate>Sat, 22 Feb 2020 18:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/seo/</guid>
      <description>网站结构优化的要素：  物理链接结构 清晰的导航 分配好子域名和目录 禁止收录机制 nofollow 使用 URL 静态化 URL 设计 404 页面 网站地图 sitemap 内部链接及权重分配 复制内容 网址规范化  物理及链接结构 物理结构是指网站真实目录和文件所在的位置决定的结构。通常有扁平式和树形结构； 扁平式适合页面数量少的网站，更多的是采用树形结构。
链接结构是指网站内部页面的链接所形成的。可以理解为复杂的树形结构。
对于搜索引擎来说，链接结构会比物理结构来的更有意义。与首页点击距离越近的页面被爬去的概率更大，权重越高。这里的点击距离就是链接结构的距离
设置合理的网站链接结构有利于页面的权重分配。
清晰的导航 是网站设计的重要目标。混乱的导航会降低被爬的概率。
 文字导航 尽量使用HTML静态文字作为导航，不要使用JS生成的动态导航，这样爬取的阻力最小。导航系统链接是整个网站收录最重要的内部链接。 点击距离扁平化 导航的目标就是让所有页面与首页点击距离越短越好，其中的页面最好不要超过4-5次点击深度。要在结构上做到扁平化。 锚文字包含关键词 导航的关键词尽量使用目标关键词 面包屑导航 中大型网站面包屑是必不可少的，它是帮助用户和搜索引擎建立页面在网站整个结构中最好的方法。 避免页脚堆积 页脚堆积关键词的做法不受搜索引擎欢迎了，尽量避免。  子域名和目录 搜索引擎通常会把子域名当成独立的站点。而目录就是该域名名下的一部分。比如http://api.abc.com 只是 http://www.abc.com 的一个子域名。 http://www.abc.com/tags 就是一个目录。 因此对主域名所做的优化，对于子域名的网站而言，同样需要再做一遍。一般的网站和博客不需要子域名。只有大型的网站才会需要。
robots 文件 该文件是搜索引擎爬行网站第一个访问的，用于告诉搜索引擎那些内容可以爬取，哪些内容禁止爬取。如果没有写规则或者没有 robots 文件的话，就是默认全部没有都可以爬取。 但是由于有的网站服务器设置问题，如果不存在 robots.txt 文件的时候，会返回 200 状态码及一些错误信息。可能会导致 spider 错误解读信息。所以建议，至少也要放一个空的 robots.txt 文件在网站根目录下。 robots 的格式如下： User-agent: * Disallow: / 复制代码上面的文件代表禁止所有搜索引擎爬取所有内容。User-agent: * 表示运行所有的搜索引擎。我们知道，不同的搜索引擎的 spider 名称也不同。在 User-agent 上你也可以设置名称，只允许特定的搜索引擎爬取。如 User-agent: Googlebot Disallow 不添加任何路径就表示运行爬取任何内容。需要注意的是：如果要 Disallow 多个文件夹或者文件，需要写成多行。每一行 Disallow 只能写一个。 meta robots 标签 通过 也可以设置禁止搜索引擎索引本页的内容，禁止跟踪本页的链接。其中 content 的参数有：</description>
    </item>
    
    <item>
      <title>cmd的操作</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/cmd/</link>
      <pubDate>Wed, 19 Feb 2020 18:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/cmd/</guid>
      <description>npm i -g tldr 太长不想读
recursive 递归的
echo 回声 ::echo::
force 强制
change 改变 cd中的::c::
directory 文件夹/目录 cd中的::d::
make ::mk::
move ::mv::
remove ::rm::
copy ::cp::
list ::ls::
link ::ln::
find ::find::
touch ::touch::
::pwd:: 展示当前的绝对路径
clear 清屏
 查看文件内容 cat 路径 全部查看
head 路径 头10行
tail 路径 尾10行
less 路径 看其中一屏部分
 增 touch 文件名
echo 内容 &amp;gt; 1.js //新建文件并添加内容
echo 内容 &amp;gt;&amp;gt; 1.js //追加内容到文件
echo -e “内/n容” &amp;gt;&amp;gt; 1.</description>
    </item>
    
    <item>
      <title>Flex &amp; Grid</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/flex-grid/</link>
      <pubDate>Wed, 12 Feb 2020 18:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/flex-grid/</guid>
      <description>Flexbox display: flex; align-items纵向对齐元素，可选以下几个值：
 flex-start: 元素与容器的顶部对齐。 flex-end: 元素与容器的底部对齐。 center: 元素纵向居中。 baseline: 元素在容器的基线位置显示。 stretch: 元素被拉伸以填满整个容器。  justify-content横向对齐元素:
 space-between ：分散对齐 space-around ：平均等宽横向对齐 flex-start(default)：默认 左对齐 flex-end ：右对齐 center ：居中  flex-direction属性定义了元素在容器里摆放的方向:
 row: 元素摆放的方向和文字方向一致。 row-reverse: 元素摆放的方向和文字方向相反。 column: 元素从上放到下。 column-reverse: 元素从下放到上。  order属性 设置单个元素的order。元素的属性默认值为0，但是我们设置这个属性为正数或负数。改变的单个flex元素的顺序
align-self设置其中单个元素的交叉轴位置
 flex-start: 元素与容器的顶部对齐。 flex-end: 元素与容器的底部对齐。 center: 元素纵向居中。 baseline: 元素在容器的基线位置显示。 stretch: 元素被拉伸以填满整个容器。  flex-wrap
 nowrap: 所有的元素都在一行。 wrap: 元素自动换成多行。 wrap-reverse: 元素自动换成逆序的多行。  flex-flow 是 flex-direction + flex-wrap两个属性的合体 可以同时接受两个 属性值。</description>
    </item>
    
    <item>
      <title>Hugo的配置</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/hugo%E7%9A%84%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 10 Feb 2020 18:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/hugo%E7%9A%84%E9%85%8D%E7%BD%AE/</guid>
      <description>首先需要将 themes/future-imperfect/examplesite/config.toml 复制到根目录替换原文件；  baseurl = &amp;#34;/&amp;#34; # 网站根路径，可以写成你后期站点对应的域名 languageCode = &amp;#34;en-us&amp;#34; # 网站支持语言 title = &amp;#34;Hugo Future Imperfect&amp;#34; # 网站标题 theme = &amp;#34;hugo-future-imperfect&amp;#34; # 网站主题 preserveTaxonomyNames = true paginate = 3 # 文章超出几篇后产生分页 disqusShortname = &amp;#34;shortname&amp;#34; googleAnalytics = &amp;#34;&amp;#34; pluralizeListTitles = false # Set the followings to true as part of your site SEO enableRobotsTXT = true canonifyURLs = true # [params] 下面的值将会构成模板里的 .Site.Params 变量 [params] # Sets the meta tag description description = &amp;#34;HTML5 UP theme, Future Imperfect with some extra goodies, ported by Julio Pescador.</description>
    </item>
    
    <item>
      <title>toml文档格式的数据定义</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/toml/</link>
      <pubDate>Sun, 02 Feb 2020 18:22:40 +0800</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/toml/</guid>
      <description>TOML　的全称是　Tom’s Obvious, Minimal Language，因为它的作者是 GitHub　联合创始人　Tom Preston-Werner 。
 TOML是大小写敏感的 # 表示注释 可以按照自己的意愿使用空格或者Tab缩进  先写一个 Hugo 博客/md文档的配置规范 +++ title = &amp;#34;标题名称&amp;#34; description = &amp;#34;&amp;#34; //副标题 draft = false //草稿 author = &amp;#34;么了&amp;#34; date = &amp;#34;2019-04-02&amp;#34; categories = [&amp;#34;笔记&amp;#34;,博客&amp;#34;&amp;#34;] // 设置分类，支持数组格式 series = [&amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;] slug = &amp;#34;url的尾部&amp;#34; tags = [] keywords: [&amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;] featured = &amp;#34;pic01.jpg&amp;#34; //外部索引图片地址用文件夹 /年份/月份/pic.jpg featuredalt = &amp;#34;Pic 1&amp;#34; featuredpath = &amp;#34;date&amp;#34; // 也可使用绝对路径 linktitle = &amp;#34;&amp;#34; publishdate // 定时未来发布的时间 type = &amp;#34;post&amp;#34; metaDataFormat = &amp;#34;toml&amp;#34; languageCode = &amp;#34;en-us&amp;#34; date = &amp;#34;2014-09-29T21:54:53-05:00&amp;#34; weight // 排序的权重，默认按时间降序 +++ Hugo 的 markdown 文件前置数据定义结构，支持三种格式的语法类型 例如： yaml --- title: &amp;#34;My First Post&amp;#34; date: 2019-03-26T08:47:11+01:00 draft: true --- toml +++ title: &amp;#34;My First Post&amp;#34; date: 2019-03-26T08:47:11+01:00 draft: true +++ json { &amp;#34;title&amp;#34;: &amp;#34;{{ replace .</description>
    </item>
    
    <item>
      <title>节流</title>
      <link>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/throttle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ganjuemele.github.io/https-ganjuemele.github.io-/blog/throttle/</guid>
      <description>// 小程序 节流  data:{ canRetry: !0 } throttle(fn, delay) { let that = this; return function() { if(that.data.canRetry) { fn.apply(that.arguments); that.setData({canRetry: !1}) setTimeout(() =&amp;gt; that.setData({canRetry: !1}), delay) } } }, throttled() { const that = this; const retry = this.throttle(()=&amp;gt; that.actList(), 2000) retry() } </description>
    </item>
    
  </channel>
</rss>
