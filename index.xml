<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>么了&#39;s 博客</title>
    <link>/</link>
    <description>Recent content on 么了&#39;s 博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <lastBuildDate>Tue, 10 Mar 2020 15:22:40 +0800</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Vue的sync修饰符</title>
      <link>/blog/sync%E4%BF%AE%E9%A5%B0%E7%AC%A6/</link>
      <pubDate>Tue, 10 Mar 2020 15:22:40 +0800</pubDate>
      
      <guid>/blog/sync%E4%BF%AE%E9%A5%B0%E7%AC%A6/</guid>
      <description>修饰符sync 让子组件改变父组件状态的代码更容易被区分，作为编译时的语法糖存在，被扩展为一个自动更新父组件属性的v-on监听器。
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;div&amp;gt;{{bar}}&amp;lt;/div&amp;gt; &amp;lt;my-comp :foo.sync=&amp;#34;bar&amp;#34;&amp;gt;&amp;lt;/my-comp&amp;gt; // 下面扩展出来的写法 &amp;lt;!--&amp;lt;my-comp :foo=&amp;#34;bar&amp;#34; @update:foo=&amp;#34;val =&amp;gt; bar = val&amp;#34;&amp;gt;&amp;lt;/my-comp&amp;gt; --&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; Vue.component(&amp;#39;my-comp&amp;#39;, { template: &amp;#39;&amp;lt;div @click=&amp;#34;increment&amp;#34;&amp;gt;点我+1&amp;lt;/div&amp;gt;&amp;#39;, data: function() { return {copyFoo: this.foo} }, props: [&amp;#39;foo&amp;#39;], methods: { increment: function() { this.$emit(&amp;#39;update:foo&amp;#39;, ++this.copyFoo); } } }); new Vue({ el: &amp;#39;#app&amp;#39;, data: {bar: 0} }); &amp;lt;/script&amp;gt; </description>
    </item>
    
    <item>
      <title>watch和computed</title>
      <link>/blog/watch%E5%92%8Ccomputed/</link>
      <pubDate>Mon, 09 Mar 2020 20:22:40 +0800</pubDate>
      
      <guid>/blog/watch%E5%92%8Ccomputed/</guid>
      <description>watch watch 有数据监听回调的作用，用来观察和响应Vue实例上的数据变动。data数据变化执行回调，在方法中传入新的值和旧的值.
immediate: true/false
deep: true/false; //监听 obj 的时候是否往深处查。默认false
⚠️不要使用箭头函数来定义 watch 函数
watch允许执行异步操作，在得到最终结果前，设置中间状态，这些是 computed 无法做到的
 computed computed 是计算属性，不需要加括号。
会根据所依赖的数据动态显示计算结果。计算结果会被缓存，computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次回去computed的值才会重新调用对应的getter来计算
&amp;lt;div id=&amp;#34;demo&amp;#34;&amp;gt;{{ fullName }}&amp;lt;/div&amp;gt; var vm = new Vue({ el: &amp;#39;#demo&amp;#39;, data: { firstName: &amp;#39;Foo&amp;#39;, lastName: &amp;#39;Bar&amp;#39; }, computed: { fullName: function () { return this.firstName + &amp;#39; &amp;#39; + this.lastName } } }) 默认只有getter，在需要时可以提供setter
// ... computed: { fullName: { // getter  get: function () { return this.</description>
    </item>
    
    <item>
      <title>Webpack入门</title>
      <link>/blog/webpack%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sat, 07 Mar 2020 20:22:40 +0800</pubDate>
      
      <guid>/blog/webpack%E5%85%A5%E9%97%A8/</guid>
      <description>安装webpack npm init -y
yarn add webpack webpack-cli --dev
安装插件css-loader,mini-css-extract-plugin,html-webpack-plugin
完成安装，创建 src 目录
执行当前目录下的webpack npx webpack
报出警告⚠️： WARNING in configuration The &#39;mode&#39; option has not been set, webpack will fallback to &#39;production&#39; for this value. Set &#39;mode&#39; option to &#39;development&#39; or &#39;production&#39; to enable defaults for each environment.
初始化webpack.config.js 新建 webpack.config.js
const path = require(&amp;#39;path&amp;#39;); module.exports = { mode: &amp;#39;development&amp;#39;,// 生产production /开发development 	entry: &amp;#39;./src/index.js&amp;#39;, devtool: &amp;#34;inline-source-map&amp;#34;, devServer: { contentBase: &amp;#39;.</description>
    </item>
    
    <item>
      <title>MVC浅谈</title>
      <link>/blog/mvc/</link>
      <pubDate>Thu, 05 Mar 2020 20:22:40 +0800</pubDate>
      
      <guid>/blog/mvc/</guid>
      <description>MVC 三个对象分别的作用，伪代码示例 model： 数据管理，请求到的数据给 controller
view： 放视图相关的，html 渲染
controller： 监听并操作 view，调用 model 里面的数据
const Model = { data: {} 增,删,改,查(){} } const View = { html:`&amp;lt;div&amp;gt;&amp;lt;p&amp;gt;hello&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt; `, init(){} render(){} } const C = { init() { v.init() v.render() } methods(){} }  EventBus 有哪些 API，是做什么用的，给出伪代码示例 提供了 constructor; on; remove; trigger 等等方法
eventBus = $(window) m = { data: {&amp;#39;…&amp;#39;}, methods: { update(data){ 修改m.data eventBus.trigger(A) } } } 然后，用on方法监听这个事件A，一旦事件A触发（即数据变化了），就调用V的render重新渲染视图：
eventBus.on(A, ()=&amp;gt;{ v.</description>
    </item>
    
    <item>
      <title>Http和Https</title>
      <link>/blog/http/</link>
      <pubDate>Tue, 25 Feb 2020 13:13:40 +0800</pubDate>
      
      <guid>/blog/http/</guid>
      <description>HTTP协议（HyperText Transfer Protocol超文本传输协议）是因特网上应用最广泛的一种网络协议，所有www文件都必须遵守这个标准。 HTTP是一个基于TCP/IP通信协议来传递数据。  HTTP工作原理 HTTP协议工作于客户端—服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端（web服务器）发送所有请求。 web服务器根据接受的请求，向客户端发送响应信息。 HTTP默认端口：80，也可以改为8080或者其他端口。  ⚠️注意事项：
 HTTP是无连接：无连接就是限制每次连接只处理一个请求，并收到客户的应答后即断开。采用这种方式可以节省传输时间。 HTTP是媒体独立的：只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送 HTTP是无状态：无状态是指协议对于事物处理没有记忆能力。缺少状态意味着如果后续处理需要之前的信息，则必须重新传，导致每次连接传送的数据量增大  通信流程： Web Browser网络浏览器 &amp;lt;—— HTTP协议 ——&amp;gt; HTTP Server &amp;lt;———&amp;gt; CGI Program(Common Gateway Interface通用网关接口) &amp;lt;———&amp;gt; Database数据库
HTTP请求方法 1.0： GET，POST，HEAD 1.1：OPTIONS，PUT，PATCH，DELETE，TRACE和CONNECT
状态码 200 — 请求成功 301 — 资源被永久转移到其它URL 404 — 请求的资源不存在 500 — 内部服务器错误
 HTTPS HTTPS（Hyper Text Transfer Protocol over SecureSocket Layer）超文本传输安全协议， 是以安全为目标的通道，在http的基础上通过传输加密和身份验证保证了传输过程的安全性。HTTP+SSL层。 主要通过数字认证、加密算法、非对称密钥等技术完成数据加密实现互联网传输安全保护，主要设计目标：   数据保密性：保证数据内容在传输过程中不会被第三方查看 数据完整性：及时发现被第三方篡改的传输内容，如果调包，能轻松发现并拒收 身份校验安全性：保证数据到达期望的目的地   优缺点   确保数据发送到正确的客户机和服务器</description>
    </item>
    
    <item>
      <title>Git远程仓库</title>
      <link>/blog/git%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</link>
      <pubDate>Mon, 24 Feb 2020 10:22:40 +0800</pubDate>
      
      <guid>/blog/git%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</guid>
      <description>git 远程仓库 用SSH地址，复制ssh地址
ssh-keygen -t rsa -b 4096 -C 你的邮箱 cat ~/.ssh/id_rsa.pub # 得到公钥内容 ssh -T git@github.com git remote add origin git@xxxxxxx git push -u origin master 新建了一个名为 ’19-12-26’ 的公钥 id_rsa 和 id_rsa.pub
git remote add origin git@XXXXXX 在本地添加远程仓库地址
origin是远程仓库的默认名字，可以换，建议不换
⚠️不要使用https地址，因为每次都需要密码
电脑上存放私钥，github留下公钥
上传代码是用私钥加密，github用公钥解密
git push -u origin master 推送本地 master 分支到远程 origin的master 分支
⚠️如果 提示 应该git pull…，那就git pull 一下
git pull是先把远程分支合并到本地对应的分支
如果远程分支没有更新过，才能省略 git pull
-u origin master 的意思是设置上游分支
之后就不用设置上游分支课，直接git pull；git push；</description>
    </item>
    
    <item>
      <title>Git本地仓库</title>
      <link>/blog/git-local/</link>
      <pubDate>Sun, 23 Feb 2020 18:22:40 +0800</pubDate>
      
      <guid>/blog/git-local/</guid>
      <description>使用github程序 &amp;raquo; install command line tool 来安装git
git config --global user.name 你的英文名 git config --global user.email 你的邮箱 git config --global push.default simple git config --global core.quotepath false git config --global core.autocrlf input 新建目录 &amp;raquo; 进入 &amp;raquo; git init
git add 路径 //选择哪些变动是需要提交的
.gitignore 是设置不需要提交的文件 //常见有::node_modules::; ::.DS_Store::; ::.idea::; ::.vscode::
git status 查看已经提交的文件
git status -sb 查看哪些文件有冲突
git commit -m “字符串”
git commit -v
git log 查看已提交更新的版本
git add . git commit -v git reset —hard a2bv7r //commit的版本号值</description>
    </item>
    
    <item>
      <title>Axios笔记</title>
      <link>/blog/axios-note/</link>
      <pubDate>Sat, 22 Feb 2020 18:22:40 +0800</pubDate>
      
      <guid>/blog/axios-note/</guid>
      <description>Axios笔记 this.$axios.get(’/toutiao/index’, { //::这里设置域名参数:: params:{ key:’4ac7dbb103ad3977c50735edb9651431’, type:’tiyu’ }, //请求头配置 headers: {&#39;token&#39;:token } }) .then(res =&amp;gt; { this.newsList= res.data console.log(this.newsList) }) .catch( err=&amp;gt; { console.log(’新闻异常’) })  Axios 是一个基于 promise 的 HTTP 库 其特性：
 可以在浏览器中发送 XMLHttpRequests 可以在 node.js 中发送 http 请求 支持 Promise API 拦截请求和响应 能取消请求 转换请求数据和相应数据 自动转换 Json 数据 客户端支持保护安全免受 XSRF 攻击  </description>
    </item>
    
    <item>
      <title>cmd的操作</title>
      <link>/blog/cmd/</link>
      <pubDate>Wed, 19 Feb 2020 18:22:40 +0800</pubDate>
      
      <guid>/blog/cmd/</guid>
      <description>npm i -g tldr 太长不想读
recursive 递归的
echo 回声 ::echo::
force 强制
change 改变 cd中的::c::
directory 文件夹/目录 cd中的::d::
make ::mk::
move ::mv::
remove ::rm::
copy ::cp::
list ::ls::
link ::ln::
find ::find::
touch ::touch::
::pwd:: 展示当前的绝对路径
clear 清屏
 查看文件内容 cat 路径 全部查看
head 路径 头10行
tail 路径 尾10行
less 路径 看其中一屏部分
 增 touch 文件名
echo 内容 &amp;gt; 1.js //新建文件并添加内容
echo 内容 &amp;gt;&amp;gt; 1.js //追加内容到文件
echo -e “内/n容” &amp;gt;&amp;gt; 1.</description>
    </item>
    
    <item>
      <title>Hugo的配置</title>
      <link>/blog/hugo%E7%9A%84%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 10 Feb 2020 18:22:40 +0800</pubDate>
      
      <guid>/blog/hugo%E7%9A%84%E9%85%8D%E7%BD%AE/</guid>
      <description>首先需要将 themes/future-imperfect/examplesite/config.toml 复制到根目录替换原文件；  baseurl = &amp;#34;/&amp;#34; # 网站根路径，可以写成你后期站点对应的域名 languageCode = &amp;#34;en-us&amp;#34; # 网站支持语言 title = &amp;#34;Hugo Future Imperfect&amp;#34; # 网站标题 theme = &amp;#34;hugo-future-imperfect&amp;#34; # 网站主题 preserveTaxonomyNames = true paginate = 3 # 文章超出几篇后产生分页 disqusShortname = &amp;#34;shortname&amp;#34; googleAnalytics = &amp;#34;&amp;#34; pluralizeListTitles = false # Set the followings to true as part of your site SEO enableRobotsTXT = true canonifyURLs = true # [params] 下面的值将会构成模板里的 .Site.Params 变量 [params] # Sets the meta tag description description = &amp;#34;HTML5 UP theme, Future Imperfect with some extra goodies, ported by Julio Pescador.</description>
    </item>
    
    <item>
      <title>toml文档格式的数据定义</title>
      <link>/blog/toml/</link>
      <pubDate>Sun, 02 Feb 2020 18:22:40 +0800</pubDate>
      
      <guid>/blog/toml/</guid>
      <description>TOML　的全称是　Tom’s Obvious, Minimal Language，因为它的作者是 GitHub　联合创始人　Tom Preston-Werner 。
 TOML是大小写敏感的 # 表示注释 可以按照自己的意愿使用空格或者Tab缩进  先写一个 Hugo 博客/md文档的配置规范 +++ title = &amp;#34;标题名称&amp;#34; description = &amp;#34;&amp;#34; //副标题 draft = false //草稿 author = &amp;#34;么了&amp;#34; date = &amp;#34;2019-04-02&amp;#34; categories = [&amp;#34;笔记&amp;#34;,博客&amp;#34;&amp;#34;] // 设置分类，支持数组格式 series = [&amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;] slug = &amp;#34;url的尾部&amp;#34; tags = [] keywords: [&amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;] featured = &amp;#34;pic01.jpg&amp;#34; //外部索引图片地址用文件夹 /年份/月份/pic.jpg featuredalt = &amp;#34;Pic 1&amp;#34; featuredpath = &amp;#34;date&amp;#34; // 也可使用绝对路径 linktitle = &amp;#34;&amp;#34; publishdate // 定时未来发布的时间 type = &amp;#34;post&amp;#34; metaDataFormat = &amp;#34;toml&amp;#34; languageCode = &amp;#34;en-us&amp;#34; date = &amp;#34;2014-09-29T21:54:53-05:00&amp;#34; weight // 排序的权重，默认按时间降序 +++ Hugo 的 markdown 文件前置数据定义结构，支持三种格式的语法类型 例如： yaml --- title: &amp;#34;My First Post&amp;#34; date: 2019-03-26T08:47:11+01:00 draft: true --- toml +++ title: &amp;#34;My First Post&amp;#34; date: 2019-03-26T08:47:11+01:00 draft: true +++ json { &amp;#34;title&amp;#34;: &amp;#34;{{ replace .</description>
    </item>
    
  </channel>
</rss>